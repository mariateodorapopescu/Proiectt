
-- SHOW DATABASES;
-- CREATE DATABASE test;
-- Dezactivează constrângerile FOREIGN KEY
SET FOREIGN_KEY_CHECKS = 0;

use test;

-- 1. Eliminarea tuturor constrângerilor FOREIGN KEY în mod dinamic
SET @sql = '';

-- Generez comenzi de eliminare pentru fiecare constrângere FOREIGN KEY
SELECT GROUP_CONCAT(CONCAT('ALTER TABLE ', TABLE_NAME, ' DROP FOREIGN KEY ', CONSTRAINT_NAME, ';'))
INTO @sql
FROM information_schema.KEY_COLUMN_USAGE
WHERE REFERENCED_TABLE_NAME IS NOT NULL
AND TABLE_SCHEMA = DATABASE();

-- Ștergerea tuturor tabelelor existente
DROP TABLE IF EXISTS 
    angajati, 
    colors, 
    departament, 
    tipuri, 
    useri, 
    experienta, 
    proiecte, 
    echipe, 
    tasks, 
    statusuri2, 
    studii, 
    cicluri, 
    limbi_ang, 
    limbi, 
    nivel, 
    aplicari, 
    joburi, 
    tip_job, 
    tip_adev, 
    adeverinte, 
    proiecte2, 
    cv, 
    tipcon, 
    concedii, 
    data, 
    date_logs, 
    libere, 
    locatii_joburi, 
    locatii_concedii, 
    locatii_atractii, 
    locatii_departamente, 
    locatii_useri, 
    restrictii, 
    sarbatori, 
    statusuri, 
    teme, 
    testt, 
    tichete, 
    users,
    tipuri_sporuri,
    tipuri_penalizari,
    istoric_penalizari,
    istoric_sporuri,
    istoric_incetari,
    istoric_promovari,
    istoric_concedii_suplimentare,
    istoric_fluture,
    sedii, 
    cereri_demisie, 
    notificari_general,
    denumiri_pozitii,
    prezenta,
    tipuri_evenimente,
    evenimente,
    participanti_evenimente,
    notificari_task,
    interviuri, 
    membrii_echipe;

-- 1. Tabele de bază (fără foreign keys)
-- -----------------------------------------------------
-- Tabel departament
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS departament (
  id_dep INT NOT NULL AUTO_INCREMENT,
  nume_dep VARCHAR(25) NOT NULL,
  PRIMARY KEY (id_dep)
) AUTO_INCREMENT = 5;

-- -----------------------------------------------------
-- Tabel tipuri
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS tipuri (
  tip INT NOT NULL,
  denumire VARCHAR(25) NOT NULL,
  salariu INT NOT NULL,
  departament_specific INT NULL DEFAULT NULL,
  ierarhie INT DEFAULT 0,
  descriere VARCHAR(500) DEFAULT NULL,
  FOREIGN KEY (departament_specific) REFERENCES departament(id_dep),
  PRIMARY KEY (tip)
);

-- -----------------------------------------------------
-- Tabel tipuri_sporuri
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS tipuri_sporuri (
    id INT PRIMARY KEY,
    denumire VARCHAR(100) NOT NULL,
    procent INT NOT NULL
);

-- -----------------------------------------------------
-- Tabel tipuri_penalizari
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS tipuri_penalizari (
    id INT PRIMARY KEY,
    denumire VARCHAR(100) NOT NULL,
    procent INT NOT NULL
);

-- -----------------------------------------------------
-- Tabel statusuri
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS statusuri (
  status INT NOT NULL,
  nume_status VARCHAR(56) NOT NULL,
  PRIMARY KEY (status)
);

-- -----------------------------------------------------
-- Tabel statusuri2
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS statusuri2 (
    id INT PRIMARY KEY,
    procent INTEGER
);

-- -----------------------------------------------------
-- Tabel tip_adev
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS tip_adev (
    id INT PRIMARY KEY,
    denumire VARCHAR(50)
);

-- -----------------------------------------------------
-- Tabel tipcon
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS tipcon (
  tip INT NOT NULL AUTO_INCREMENT,
  motiv VARCHAR(255) NULL DEFAULT NULL,
  nr_zile INT NULL DEFAULT '0',
  PRIMARY KEY (tip)
) AUTO_INCREMENT = 6;

-- -----------------------------------------------------
-- Tabel sedii (fără foreign keys)
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS sedii (
    id_sediu INT PRIMARY KEY AUTO_INCREMENT,
    nume_sediu VARCHAR(255) NOT NULL,
    tip_sediu ENUM('principal', 'secundar', 'punct_lucru') NOT NULL,
    strada VARCHAR(255) default NULL,
    cod VARCHAR(12) default  NULL,
    oras VARCHAR(255) default NULL,
    judet VARCHAR(255) default NULL,
    tara VARCHAR(255) default NULL,
    telefon VARCHAR(20) not null,
    email VARCHAR(100) not null,
    latitudine DOUBLE default null,
    longitudine DOUBLE default null,
    data_creare TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    data_modificare TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 2. Rezolvare referințe circulare: useri -> echipe -> proiecte -> useri
-- Creăm tabelul useri fără referința către echipe inițial
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS useri (
  id INT NOT NULL AUTO_INCREMENT,
  nume VARCHAR(45) NOT NULL,
  prenume VARCHAR(45) NOT NULL,
  data_nasterii DATE NOT NULL,
  adresa VARCHAR(256) NULL DEFAULT NULL,
  email VARCHAR(56) NOT NULL,
  telefon VARCHAR(25) NOT NULL,
  username VARCHAR(25) NOT NULL,
  password VARCHAR(255) NOT NULL,
  id_dep INT NOT NULL,
  tip INT NOT NULL,
  zilecons INT NULL DEFAULT '0',
  zileramase INT NULL DEFAULT '40',
  conluate INT NULL DEFAULT '0',
  conramase INT NULL DEFAULT '3',
  cnp VARCHAR(14) NULL DEFAULT NULL,
  culoare VARCHAR(25) NOT NULL DEFAULT '#333',
  activ INT NULL DEFAULT '0',
  profil MEDIUMBLOB NULL DEFAULT NULL,
  data_ang DATE NULL DEFAULT NULL,
  data_modif DATE NULL DEFAULT NULL,
  id_sediu INT NULL DEFAULT NULL,
  PRIMARY KEY (id),
  FOREIGN KEY (id_sediu) REFERENCES sedii(id_sediu),
  FOREIGN KEY (id_dep) REFERENCES departament(id_dep),
  FOREIGN KEY (tip) REFERENCES tipuri(tip)
  -- id_echipa va fi adăugat ca foreign key la final
);

-- Creare indexuri pentru useri
CREATE UNIQUE INDEX username ON useri (username ASC);
CREATE UNIQUE INDEX cnp ON useri (cnp ASC);
CREATE UNIQUE INDEX email ON useri (email ASC);
CREATE UNIQUE INDEX telefon ON useri (telefon ASC);

-- -----------------------------------------------------
-- Tabel proiecte (fără referință către echipe)
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS proiecte (
    id INT PRIMARY KEY AUTO_INCREMENT,
    nume VARCHAR(50),
    descriere VARCHAR(1000),
    start DATE,
    end DATE,
    supervizor INT,
    FOREIGN KEY (supervizor) REFERENCES useri(id)
);

-- -----------------------------------------------------
-- Tabel echipe
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS echipe (
    id INT PRIMARY KEY AUTO_INCREMENT,
    nume VARCHAR(50),
    supervizor INT,
    id_prj INT,
    FOREIGN KEY (supervizor) REFERENCES useri(id),
    FOREIGN KEY (id_prj) REFERENCES proiecte(id)
);

-- -----------------------------------------------------
-- Tabel istoric_penalizari
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS istoric_penalizari (
    id INT PRIMARY KEY AUTO_INCREMENT,
    id_ang INT NOT NULL,
    tip_penalizare INT NOT NULL,
    data_start DATE NOT NULL,
    data_final DATE NOT NULL,
    motiv VARCHAR(500),
    data_creare TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (id_ang) REFERENCES useri(id),
    FOREIGN KEY (tip_penalizare) REFERENCES tipuri_penalizari(id)
);

-- -----------------------------------------------------
-- Tabel istoric_sporuri
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS istoric_sporuri (
    id INT PRIMARY KEY AUTO_INCREMENT,
    id_ang INT NOT NULL,
    tip_spor INT NOT NULL,
    data_start DATE NOT NULL,
    data_final DATE NOT NULL,
    motiv VARCHAR(500),
    data_creare TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (id_ang) REFERENCES useri(id),
    FOREIGN KEY (tip_spor) REFERENCES tipuri_sporuri(id)
);

-- -----------------------------------------------------
-- Tabel istoric_incetari
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS istoric_incetari (
    id INT PRIMARY KEY AUTO_INCREMENT,
    id_ang INT NOT NULL,
    data_incetare DATE NOT NULL,
    motiv VARCHAR(100) NOT NULL,
    observatii TEXT,
    data_creare TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (id_ang) REFERENCES useri(id)
);

-- -----------------------------------------------------
-- Tabel istoric_promovari
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS istoric_promovari (
    id INT PRIMARY KEY AUTO_INCREMENT,
    id_ang INT NOT NULL,
    tip_vechi INT NOT NULL,
    tip_nou INT NOT NULL,
    tip_promovare VARCHAR(50) NOT NULL,
    data_promovare DATE NOT NULL,
    FOREIGN KEY (id_ang) REFERENCES useri(id),
    FOREIGN KEY (tip_vechi) REFERENCES tipuri(tip),
    FOREIGN KEY (tip_nou) REFERENCES tipuri(tip)
);

-- -----------------------------------------------------
-- Tabel istoric_fluture
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS istoric_fluture (
    id INT PRIMARY KEY AUTO_INCREMENT,
    id_ang INT NOT NULL,
    luna INT NOT NULL,
    an INT NOT NULL,
    salariu_brut DECIMAL(10,2) NOT NULL,
    salariu_net DECIMAL(10,2) NOT NULL,
    data_generare DATE NOT NULL,
    FOREIGN KEY (id_ang) REFERENCES useri(id)
);

-- -----------------------------------------------------
-- Tabel tasks
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS tasks (
    id INT PRIMARY KEY auto_increment,
    nume VARCHAR(50),
    supervizor INT,
    id_ang INT,
    start DATE,
    end DATE,
    status INT DEFAULT 0,
    id_prj INT,
    FOREIGN KEY (supervizor) REFERENCES useri(id),
    FOREIGN KEY (id_prj) REFERENCES proiecte(id),
    FOREIGN KEY (id_ang) REFERENCES useri(id),
    FOREIGN KEY (status) REFERENCES statusuri2(id)
);

-- -----------------------------------------------------
-- Tabel locatii_joburi
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS locatii_joburi (
  id_locatie INT NOT NULL AUTO_INCREMENT,
  id_job INT NOT NULL,
  strada VARCHAR(255) NOT NULL,
  longitudine DOUBLE NULL DEFAULT NULL,
  latitudine DOUBLE NULL DEFAULT NULL,
  cod VARCHAR(12) NOT NULL,
  oras VARCHAR(255) NOT NULL,
  judet VARCHAR(255) NOT NULL,
  tara VARCHAR(255) NOT NULL,
  PRIMARY KEY (id_locatie)
);

-- -----------------------------------------------------
-- Tabel joburi
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS joburi (
    id INT PRIMARY KEY auto_increment,
    titlu VARCHAR(50),
    req VARCHAR(1000),
    resp VARCHAR(1000),
    dom VARCHAR(50),
    subdom VARCHAR(50),
    pozitie INT,
    departament INT,
    start DATE,
    end DATE,
    id_locatie INTEGER, 
    activ BOOLEAN,
    keywords VARCHAR(100),
    id_team INTEGER,
    id_prj INTEGER,
    ore INTEGER,
    tip BOOLEAN,
    FOREIGN KEY (id_team) REFERENCES echipe(id), 
    FOREIGN KEY (id_prj) REFERENCES proiecte(id),
    FOREIGN KEY (pozitie) REFERENCES tipuri(tip),
    FOREIGN KEY (departament) REFERENCES departament(id_dep),
    FOREIGN KEY (id_locatie) REFERENCES locatii_joburi(id_locatie)
);

-- -----------------------------------------------------
-- Tabel adeverinte
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS adeverinte (
    id INT PRIMARY KEY,
    tip INT,
    motiv VARCHAR(255),
    status INT,
    creare DATE,
    modif DATE,
    id_ang INT NOT NULL,
    pentru_servi VARCHAR(255),
    FOREIGN KEY (tip) REFERENCES tip_adev(id),
    FOREIGN KEY (id_ang) REFERENCES useri(id),
    FOREIGN KEY (status) REFERENCES statusuri(status)
);

-- -----------------------------------------------------
-- Tabel concedii
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS concedii (
  id INT NOT NULL AUTO_INCREMENT,
  id_ang INT NOT NULL,
  start_c DATE NOT NULL,
  end_c DATE NOT NULL,
  motiv VARCHAR(256) NOT NULL,
  locatie VARCHAR(256) NOT NULL,
  status INT NULL DEFAULT '0',
  tip INT NOT NULL,
  durata INT NOT NULL DEFAULT '0',
  added DATE NULL DEFAULT NULL,
  modified DATE NULL DEFAULT NULL,
  acc_res DATE NULL DEFAULT NULL,
  mentiuni VARCHAR(256) default NULL,
  PRIMARY KEY (id),
  FOREIGN KEY (id_ang) REFERENCES useri(id),
  FOREIGN KEY (status) REFERENCES statusuri(status),
  FOREIGN KEY (tip) REFERENCES tipcon(tip)
);

-- -----------------------------------------------------
-- Tabel teme
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS teme (
  id_usr INT NOT NULL,
  accent VARCHAR(25) NULL DEFAULT '#10439F',
  clr VARCHAR(25) NULL DEFAULT '#d8d9e1',
  sidebar VARCHAR(25) NULL DEFAULT '#ECEDFA',
  card VARCHAR(25) NULL DEFAULT '#ECEDFA',
  text VARCHAR(25) NULL DEFAULT '#333',
  hover VARCHAR(25) NULL DEFAULT '#ECEDFA',
  PRIMARY KEY (id_usr),
  FOREIGN KEY (id_usr) REFERENCES useri(id)
);

-- 5. Tabele care depind de alte tabele
-- -----------------------------------------------------
-- Tabel locatii_concedii
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS locatii_concedii (
  id_locatie INT NOT NULL AUTO_INCREMENT,
  id_concediu INT NOT NULL,
  strada VARCHAR(255) NOT NULL,
  longitudine DOUBLE NULL DEFAULT NULL,
  latitudine DOUBLE NULL DEFAULT NULL,
  cod VARCHAR(12) NOT NULL,
  oras VARCHAR(255) NOT NULL,
  judet VARCHAR(255) NOT NULL,
  tara VARCHAR(255) NOT NULL,
  PRIMARY KEY (id_locatie),
  FOREIGN KEY (id_concediu) REFERENCES concedii(id)
);

-- -----------------------------------------------------
-- Tabel locatii_atractii
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS locatii_atractii (
  id_locatie INT NOT NULL AUTO_INCREMENT,
  nume varchar(255) not null,
  strada VARCHAR(255) NOT NULL,
  longitudine DOUBLE NULL DEFAULT NULL,
  latitudine DOUBLE NULL DEFAULT NULL,
  cod VARCHAR(12) NOT NULL,
  oras VARCHAR(255) NOT NULL,
  judet VARCHAR(255) NOT NULL,
  tara VARCHAR(255) NOT NULL,
  PRIMARY KEY (id_locatie)
);

-- -----------------------------------------------------
-- Tabel locatii_departamente
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS locatii_departamente (
  id_dep INT NOT NULL,
  strada VARCHAR(255) NOT NULL,
  longitudine DOUBLE NULL DEFAULT NULL,
  latitudine DOUBLE NULL DEFAULT NULL,
  cod VARCHAR(12) NOT NULL,
  oras VARCHAR(255) NOT NULL,
  judet VARCHAR(255) NOT NULL,
  tara VARCHAR(255) NOT NULL,
  PRIMARY KEY (id_dep),
  FOREIGN KEY (id_dep) REFERENCES departament(id_dep)
);

-- -----------------------------------------------------
-- Tabel locatii_useri
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS locatii_useri (
  id_locatie INT NOT NULL AUTO_INCREMENT,
  id_user INT NOT NULL,
  strada VARCHAR(255) NOT NULL,
  longitudine DOUBLE NULL DEFAULT NULL,
  latitudine DOUBLE NULL DEFAULT NULL,
  cod VARCHAR(12) NOT NULL,
  oras VARCHAR(255) NOT NULL,
  judet VARCHAR(255) NOT NULL,
  tara VARCHAR(255) NOT NULL,
  id_sediu INT DEFAULT NULL,
  PRIMARY KEY (id_locatie),
  FOREIGN KEY (id_user) REFERENCES useri(id),
  FOREIGN KEY (id_sediu) REFERENCES sedii(id_sediu)
);

-- -----------------------------------------------------
-- Tabel denumiri_pozitii
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS denumiri_pozitii (
    id INT PRIMARY KEY AUTO_INCREMENT,
    tip_pozitie INT NOT NULL,
    id_dep INT NOT NULL,
    denumire_completa VARCHAR(255) NOT NULL,
    activ BOOLEAN DEFAULT TRUE,
    FOREIGN KEY (tip_pozitie) REFERENCES tipuri(tip),
    FOREIGN KEY (id_dep) REFERENCES departament(id_dep),
    UNIQUE KEY uq_tip_dep (tip_pozitie, id_dep)
);

-- -----------------------------------------------------
-- Tabel membrii_echipe
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS membrii_echipe (
  id INT NOT NULL AUTO_INCREMENT,
  id_ang int NOT NULL,
  id_echipa int not null,
  FOREIGN KEY (id_ang) REFERENCES useri(id),
  FOREIGN KEY (id_echipa) REFERENCES echipe(id),
  PRIMARY KEY (id)  
) AUTO_INCREMENT = 5;

-- -----------------------------------------------------
-- Tabel sarbatori
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS sarbatori (
  zi DATE NULL DEFAULT NULL,
  nume VARCHAR(255) NULL DEFAULT NULL
);

-- -----------------------------------------------------
-- Tabel libere
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS libere (
  zi DATE NULL DEFAULT NULL,
  nume VARCHAR(255) NULL DEFAULT NULL
);

-- -----------------------------------------------------
-- Tabel cereri_demisie
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS cereri_demisie (
    id INT PRIMARY KEY AUTO_INCREMENT,
    id_ang INT NOT NULL,
    motiv TEXT NOT NULL,
    data_cerere DATE NOT NULL,
    data_ultima_zi DATE NOT NULL,
    status ENUM('IN_ASTEPTARE', 'APROBATA', 'RESPINSA') DEFAULT 'IN_ASTEPTARE',
    data_procesare DATE,
    FOREIGN KEY (id_ang) REFERENCES useri(id)
);
CREATE TABLE IF NOT EXISTS log_activitati_simple (
    id INT PRIMARY KEY AUTO_INCREMENT,
    id_user INT,                               -- Cine a făcut acțiunea (din useri.id)
    id_target INT,                             -- Asupra cui s-a făcut (din useri.id) 
    actiune VARCHAR(50) NOT NULL,              -- Tip acțiune: 'VIEW', 'EDIT', 'PROMOTE', etc.
    descriere TEXT,                            -- Descriere liberă
    tabel_afectat VARCHAR(50),                 -- Ce tabel a fost afectat
    data_actiune TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ip_address VARCHAR(45),                    -- IP-ul utilizatorului
    
    -- Foreign keys către tabelul existent
    FOREIGN KEY (id_user) REFERENCES useri(id) ON DELETE SET NULL,
    FOREIGN KEY (id_target) REFERENCES useri(id) ON DELETE SET NULL,
    
    -- Indexuri pentru performanță
    INDEX idx_user (id_user),
    INDEX idx_target (id_target),
    INDEX idx_actiune (actiune),
    INDEX idx_data (data_actiune)
);

-- -----------------------------------------------------
-- VIEW-URI PENTRU DOSARUL COMPLET (folosind tabelele existente)
-- -----------------------------------------------------

-- View pentru dosarul complet al angajatului
CREATE OR REPLACE VIEW v_dosar_angajat_complet AS
SELECT 
    u.id,
    u.nume,
    u.prenume,
    CONCAT(u.nume, ' ', u.prenume) as nume_complet,
    u.email,
    u.telefon,
    u.cnp,
    u.data_nasterii,
    u.data_ang,
    u.data_modif,
    u.activ,
    u.zilecons,
    u.conluate,
    u.zileramase,
    u.conramase,
    
    -- Informații departament și poziție
    d.nume_dep as departament,
    t.denumire as pozitie,
    t.salariu as salariu_baza,
    t.ierarhie,
    t.descriere as descriere_pozitie,
    
    -- Sporuri active (folosind tabelul existent istoric_sporuri)
    (SELECT GROUP_CONCAT(DISTINCT CONCAT(ts.denumire, ' (', ts.procent, '%)') SEPARATOR ', ')
     FROM istoric_sporuri isp 
     JOIN tipuri_sporuri ts ON isp.tip_spor = ts.id
     WHERE isp.id_ang = u.id 
     AND isp.data_start <= CURDATE() 
     AND isp.data_final >= CURDATE()) as sporuri_active,
    
    -- Penalizări active (folosind tabelul existent istoric_penalizari)
    (SELECT GROUP_CONCAT(DISTINCT CONCAT(tp.denumire, ' (', tp.procent, '%)') SEPARATOR ', ')
     FROM istoric_penalizari ipe 
     JOIN tipuri_penalizari tp ON ipe.tip_penalizare = tp.id
     WHERE ipe.id_ang = u.id 
     AND ipe.data_start <= CURDATE() 
     AND ipe.data_final >= CURDATE()) as penalizari_active,
    
    -- Total sporuri și penalizări (pentru calcul salariu)
    COALESCE((SELECT SUM(ts.procent * t.salariu / 100)
              FROM istoric_sporuri isp 
              JOIN tipuri_sporuri ts ON isp.tip_spor = ts.id
              WHERE isp.id_ang = u.id 
              AND isp.data_start <= CURDATE() 
              AND isp.data_final >= CURDATE()), 0) as total_sporuri,
              
    COALESCE((SELECT SUM(tp.procent * t.salariu / 100)
              FROM istoric_penalizari ipe 
              JOIN tipuri_penalizari tp ON ipe.tip_penalizare = tp.id
              WHERE ipe.id_ang = u.id 
              AND ipe.data_start <= CURDATE() 
              AND ipe.data_final >= CURDATE()), 0) as total_penalizari,
    
    -- Numărul de promovări (folosind tabelul existent istoric_promovari)
    (SELECT COUNT(*) 
     FROM istoric_promovari ip 
     WHERE ip.id_ang = u.id) as numar_promovari,
    
    -- Ultima promovare
    (SELECT DATE_FORMAT(MAX(ip.data_promovare), '%d.%m.%Y')
     FROM istoric_promovari ip 
     WHERE ip.id_ang = u.id) as ultima_promovare,
    
    -- Experiența în companie (ani)
    TIMESTAMPDIFF(YEAR, u.data_ang, CURDATE()) as experienta_ani,
    
    -- Zile de concediu consumate anul curent (folosind tabelul existent concedii)
    (SELECT COALESCE(SUM(DATEDIFF(c.end_c, c.start_c) + 1), 0)
     FROM concedii c 
     WHERE c.id_ang = u.id 
     AND YEAR(c.start_c) = YEAR(CURDATE())
     AND c.status >= 1) as zile_concediu_consumate_anul_curent,
     
    -- Proiecte active (folosind tabelele existente)
    (SELECT GROUP_CONCAT(DISTINCT p.nume SEPARATOR ', ')
     FROM proiecte p
     JOIN echipe e ON p.id = e.id_prj
     JOIN membrii_echipe me ON e.id = me.id_echipa
     WHERE me.id_ang = u.id
     AND p.start <= CURDATE() 
     AND p.end >= CURDATE()) as proiecte_active,
     
    -- Task-uri active (folosind tabelul existent tasks)
    (SELECT COUNT(*)
     FROM tasks t
     WHERE t.id_ang = u.id
     AND (t.end IS NULL OR t.end >= CURDATE())) as tasks_active,
     
    -- Locația (folosind tabelul existent locatii_useri)
    (SELECT CONCAT(l.strada, ', ', l.oras, ', ', l.judet, ', ', l.tara)
     FROM locatii_useri l 
     WHERE l.id_user = u.id 
     LIMIT 1) as adresa

FROM useri u
JOIN departament d ON u.id_dep = d.id_dep
JOIN tipuri t ON u.tip = t.tip
WHERE u.username != 'test';

-- -----------------------------------------------------
-- VIEW pentru statistici departament
-- -----------------------------------------------------
CREATE OR REPLACE VIEW v_statistici_departament AS
SELECT 
    d.id_dep,
    d.nume_dep,
    COUNT(u.id) as total_angajati,
    COUNT(CASE WHEN u.activ = 1 THEN 1 END) as angajati_activi,
    AVG(t.salariu) as salariu_mediu,
    MIN(t.salariu) as salariu_minim,
    MAX(t.salariu) as salariu_maxim,
    AVG(TIMESTAMPDIFF(YEAR, u.data_ang, CURDATE())) as vechime_medie,
    
    -- Concedii în curs
    (SELECT COUNT(*)
     FROM concedii c
     JOIN useri u2 ON c.id_ang = u2.id
     WHERE u2.id_dep = d.id_dep
     AND c.start_c <= CURDATE()
     AND c.end_c >= CURDATE()
     AND c.status >= 1) as angajati_in_concediu,
     
    -- Promovări anul acesta
    (SELECT COUNT(*)
     FROM istoric_promovari ip
     JOIN useri u3 ON ip.id_ang = u3.id
     WHERE u3.id_dep = d.id_dep
     AND YEAR(ip.data_promovare) = YEAR(CURDATE())) as promovari_anul_curent
     
FROM departament d
LEFT JOIN useri u ON d.id_dep = u.id_dep AND u.username != 'test'
LEFT JOIN tipuri t ON u.tip = t.tip
GROUP BY d.id_dep, d.nume_dep;

-- -----------------------------------------------------
-- PROCEDURĂ pentru audit trail simplu
-- -----------------------------------------------------
DELIMITER $$
DROP PROCEDURE IF EXISTS sp_log_activitate$$
CREATE PROCEDURE sp_log_activitate(
    IN p_id_user INT,
    IN p_id_target INT,
    IN p_actiune VARCHAR(50),
    IN p_descriere TEXT,
    IN p_tabel VARCHAR(50),
    IN p_ip VARCHAR(45)
)
BEGIN
    INSERT INTO log_activitati_simple (
        id_user, id_target, actiune, descriere, tabel_afectat, ip_address
    ) VALUES (
        p_id_user, p_id_target, p_actiune, p_descriere, p_tabel, p_ip
    );
END$$

-- -----------------------------------------------------
-- PROCEDURĂ pentru generarea raportului complet al angajatului
-- -----------------------------------------------------
DROP PROCEDURE IF EXISTS sp_genereaza_dosar_angajat_complet$$
CREATE PROCEDURE sp_genereaza_dosar_angajat_complet(
    IN p_id_angajat INT
)
BEGIN
    -- Declaram handlerul pentru erori
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;
    
    START TRANSACTION;
    
    -- Log activitatea de vizualizare dosar
    CALL sp_log_activitate(
        COALESCE(@current_user_id, 1), 
        p_id_angajat, 
        'VIEW_DOSSIER',
        CONCAT('Vizualizare dosar complet angajat ID: ', p_id_angajat),
        'useri',
        COALESCE(@current_user_ip, '127.0.0.1')
    );
    
    -- 1. Informații generale din view-ul principal
    SELECT 'INFORMATII_GENERALE' as sectiune;
    SELECT * FROM v_dosar_angajat_complet WHERE id = p_id_angajat;
    
    -- 2. Istoric promovări (din tabelul existent)
    SELECT 'ISTORIC_PROMOVARI' as sectiune;
    SELECT 
        ip.data_promovare,
        t1.denumire as pozitie_veche,
        t1.salariu as salariu_vechi,
        t2.denumire as pozitie_noua,
        t2.salariu as salariu_nou,
        ip.tip_promovare,
        (t2.salariu - t1.salariu) as diferenta_salariu
    FROM istoric_promovari ip
    JOIN tipuri t1 ON ip.tip_vechi = t1.tip
    JOIN tipuri t2 ON ip.tip_nou = t2.tip
    WHERE ip.id_ang = p_id_angajat
    ORDER BY ip.data_promovare DESC;
    
    -- 3. Istoric sporuri (din tabelul existent)
    SELECT 'ISTORIC_SPORURI' as sectiune;
    SELECT 
        ts.denumire as tip_spor,
        ts.procent,
        isp.data_start,
        isp.data_final,
        isp.motiv,
        isp.data_creare,
        CASE 
            WHEN isp.data_start <= CURDATE() AND isp.data_final >= CURDATE() 
            THEN 'ACTIV' 
            ELSE 'EXPIRAT' 
        END as status
    FROM istoric_sporuri isp
    JOIN tipuri_sporuri ts ON isp.tip_spor = ts.id
    WHERE isp.id_ang = p_id_angajat
    ORDER BY isp.data_start DESC;
    
    -- 4. Istoric penalizări (din tabelul existent)
    SELECT 'ISTORIC_PENALIZARI' as sectiune;
    SELECT 
        tp.denumire as tip_penalizare,
        tp.procent,
        ipe.data_start,
        ipe.data_final,
        ipe.motiv,
        ipe.data_creare,
        CASE 
            WHEN ipe.data_start <= CURDATE() AND ipe.data_final >= CURDATE() 
            THEN 'ACTIV' 
            ELSE 'EXPIRAT' 
        END as status
    FROM istoric_penalizari ipe
    JOIN tipuri_penalizari tp ON ipe.tip_penalizare = tp.id
    WHERE ipe.id_ang = p_id_angajat
    ORDER BY ipe.data_start DESC;
    
    -- 5. Istoric concedii (din tabelul existent)
    SELECT 'ISTORIC_CONCEDII' as sectiune;
    SELECT 
        tc.motiv as tip_concediu,
        tc.nr_zile as zile_standard,
        c.start_c,
        c.end_c,
        DATEDIFF(c.end_c, c.start_c) + 1 as zile_efective,
        s.nume_status as status,
        c.motiv as motiv_specific,
        c.locatie,
        c.added as data_cerere,
        c.modified as data_ultima_modificare
    FROM concedii c
    JOIN tipcon tc ON c.tip = tc.tip
    JOIN statusuri s ON c.status = s.status
    WHERE c.id_ang = p_id_angajat
    ORDER BY c.start_c DESC;
    
    -- 6. Proiecte și echipe (din tabelele existente)
    SELECT 'PROIECTE_ECHIPE' as sectiune;
    SELECT 
        p.nume as nume_proiect,
        p.descriere as descriere_proiect,
        p.start as data_start_proiect,
        p.end as data_end_proiect,
        e.nume as nume_echipa,
        CONCAT(supervizor.nume, ' ', supervizor.prenume) as supervizor_echipa,
        CASE 
            WHEN p.start <= CURDATE() AND p.end >= CURDATE() 
            THEN 'ACTIV' 
            WHEN p.end < CURDATE() 
            THEN 'FINALIZAT'
            ELSE 'VIITOR'
        END as status_proiect
    FROM membrii_echipe me
    JOIN echipe e ON me.id_echipa = e.id
    JOIN proiecte p ON e.id_prj = p.id
    LEFT JOIN useri supervizor ON e.supervizor = supervizor.id
    WHERE me.id_ang = p_id_angajat
    ORDER BY p.start DESC;
    
    -- 7. Task-uri asignate (din tabelul existent)
    SELECT 'TASKS_ASIGNATE' as sectiune;
    SELECT 
        t.nume as nume_task,
        t.start as data_start,
        t.end as data_deadline,
        s2.procent as progres,
        p.nume as nume_proiect,
        CONCAT(supervizor.nume, ' ', supervizor.prenume) as supervizor,
        CASE 
            WHEN t.end IS NULL THEN 'FARA_DEADLINE'
            WHEN t.end < CURDATE() AND s2.procent < 100 THEN 'INTARZIAT'
            WHEN s2.procent = 100 THEN 'COMPLETAT'
            ELSE 'IN_PROGRES'
        END as status_task
    FROM tasks t
    LEFT JOIN statusuri2 s2 ON t.status = s2.id
    LEFT JOIN proiecte p ON t.id_prj = p.id
    LEFT JOIN useri supervizor ON t.supervizor = supervizor.id
    WHERE t.id_ang = p_id_angajat
    ORDER BY t.start DESC;
    
    -- 8. Studii și calificări (din tabelul existent)
    SELECT 'STUDII_CALIFICARI' as sectiune;
    SELECT 
        s.facultate,
        s.universitate,
        c.semnificatie as nivel_studii,
        s.start as data_start,
        s.end as data_absolvire,
        TIMESTAMPDIFF(YEAR, s.start, s.end) as durata_ani
    FROM studii s
    JOIN cicluri c ON s.ciclu = c.id
    WHERE s.id_ang = p_id_angajat
    ORDER BY s.start DESC;
    
    -- 9. Competențe lingvistice (din tabelele existente)
    SELECT 'COMPETENTE_LINGVISTICE' as sectiune;
    SELECT 
        l.limba,
        n.semnificatie as nivel
    FROM limbi_ang la
    JOIN limbi l ON la.id_limba = l.id
    JOIN nivel n ON la.id_nivel = n.id
    WHERE la.id_ang = p_id_angajat
    ORDER BY l.limba;
    
    -- 10. Istoric fluture salarial (din tabelul existent)
    SELECT 'ISTORIC_SALARIAL' as sectiune;
    SELECT 
        hf.luna,
        hf.an,
        hf.salariu_brut,
        hf.salariu_net,
        hf.data_generare,
        CONCAT(hf.luna, '/', hf.an) as perioada
    FROM istoric_fluture hf
    WHERE hf.id_ang = p_id_angajat
    ORDER BY hf.an DESC, hf.luna DESC
    LIMIT 24; -- Ultimele 24 luni
    
    -- 11. Log activități recente (din noua tabelă minimală)
    SELECT 'LOG_ACTIVITATI' as sectiune;
    SELECT 
        las.actiune,
        las.descriere,
        las.tabel_afectat,
        las.data_actiune,
        CONCAT(u.nume, ' ', u.prenume) as executat_de,
        las.ip_address
    FROM log_activitati_simple las
    LEFT JOIN useri u ON las.id_user = u.id
    WHERE las.id_target = p_id_angajat OR las.id_user = p_id_angajat
    ORDER BY las.data_actiune DESC
    LIMIT 50;
    
    COMMIT;
    
    -- Returnează și un mesaj de succes
    SELECT CONCAT('Dosar generat cu succes pentru angajatul cu ID: ', p_id_angajat) as mesaj_succes;
END$

-- -----------------------------------------------------
-- PROCEDURĂ pentru promovarea unui angajat (folosește tabelele existente)
-- -----------------------------------------------------
DROP PROCEDURE IF EXISTS sp_promoveaza_angajat_complet$
CREATE PROCEDURE sp_promoveaza_angajat_complet(
    IN p_id_angajat INT,
    IN p_tip_nou INT,
    IN p_tip_promovare VARCHAR(50),
    IN p_data_promovare DATE,
    IN p_user_id INT,
    IN p_motiv TEXT
)
BEGIN
    DECLARE v_tip_vechi INT;
    DECLARE v_nume_angajat VARCHAR(91);
    DECLARE v_salariu_vechi INT;
    DECLARE v_salariu_nou INT;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;
    
    START TRANSACTION;
    
    -- Obține tipul actual și numele angajatului
    SELECT u.tip, CONCAT(u.nume, ' ', u.prenume), t.salariu
    INTO v_tip_vechi, v_nume_angajat, v_salariu_vechi
    FROM useri u
    JOIN tipuri t ON u.tip = t.tip
    WHERE u.id = p_id_angajat;
    
    -- Obține salariul pentru noua poziție
    SELECT salariu INTO v_salariu_nou FROM tipuri WHERE tip = p_tip_nou;
    
    -- Setează utilizatorul curent pentru logging
    SET @current_user_id = p_user_id;
    
    -- Actualizează tipul angajatului în tabelul existent
    UPDATE useri 
    SET tip = p_tip_nou, data_modif = CURDATE()
    WHERE id = p_id_angajat;
    
    -- Adaugă înregistrarea în tabelul existent istoric_promovari
    INSERT INTO istoric_promovari (
        id_ang, tip_vechi, tip_nou, tip_promovare, data_promovare
    ) VALUES (
        p_id_angajat, v_tip_vechi, p_tip_nou, p_tip_promovare, p_data_promovare
    );
    
    -- Log în noua tabelă de audit
    CALL sp_log_activitate(
        p_user_id,
        p_id_angajat,
        'PROMOTE',
        CONCAT('Promovare: ', v_nume_angajat, ' de la ', 
               (SELECT denumire FROM tipuri WHERE tip = v_tip_vechi),
               ' (', v_salariu_vechi, ' RON) la ',
               (SELECT denumire FROM tipuri WHERE tip = p_tip_nou),
               ' (', v_salariu_nou, ' RON). Motiv: ', COALESCE(p_motiv, 'N/A')),
        'useri,istoric_promovari',
        COALESCE(@current_user_ip, '127.0.0.1')
    );
    
    COMMIT;
    
    SELECT CONCAT('Angajatul ', v_nume_angajat, ' a fost promovat cu succes de la ', 
                  (SELECT denumire FROM tipuri WHERE tip = v_tip_vechi), ' la ',
                  (SELECT denumire FROM tipuri WHERE tip = p_tip_nou), '!') as mesaj;
END$

-- -----------------------------------------------------
-- PROCEDURĂ pentru calculul salariului cu sporuri/penalizări
-- -----------------------------------------------------
DROP PROCEDURE IF EXISTS sp_calculeaza_salariu_net$
CREATE PROCEDURE sp_calculeaza_salariu_net(
    IN p_id_angajat INT,
    IN p_data_calcul DATE
)
BEGIN
    DECLARE v_salariu_baza DECIMAL(10,2);
    DECLARE v_total_sporuri DECIMAL(10,2) DEFAULT 0;
    DECLARE v_total_penalizari DECIMAL(10,2) DEFAULT 0;
    DECLARE v_salariu_brut DECIMAL(10,2);
    DECLARE v_salariu_net DECIMAL(10,2);
    
    -- Obține salariul de bază din tabelul existent
    SELECT t.salariu INTO v_salariu_baza
    FROM useri u
    JOIN tipuri t ON u.tip = t.tip
    WHERE u.id = p_id_angajat;
    
    -- Calculează sporurile active pentru data specificată
    SELECT COALESCE(SUM(ts.procent * v_salariu_baza / 100), 0) INTO v_total_sporuri
    FROM istoric_sporuri isp
    JOIN tipuri_sporuri ts ON isp.tip_spor = ts.id
    WHERE isp.id_ang = p_id_angajat
    AND p_data_calcul BETWEEN isp.data_start AND isp.data_final;
    
    -- Calculează penalizările active pentru data specificată
    SELECT COALESCE(SUM(tp.procent * v_salariu_baza / 100), 0) INTO v_total_penalizari
    FROM istoric_penalizari ipe
    JOIN tipuri_penalizari tp ON ipe.tip_penalizare = tp.id
    WHERE ipe.id_ang = p_id_angajat
    AND p_data_calcul BETWEEN ipe.data_start AND ipe.data_final;
    
    -- Calculează salariul brut și net
    SET v_salariu_brut = v_salariu_baza + v_total_sporuri - v_total_penalizari;
    SET v_salariu_net = v_salariu_brut * 0.585; -- Aproximativ după taxe (simplificat)
    
    -- Returnează rezultatul
    SELECT 
        p_id_angajat as id_angajat,
        p_data_calcul as data_calcul,
        v_salariu_baza as salariu_baza,
        v_total_sporuri as total_sporuri,
        v_total_penalizari as total_penalizari,
        v_salariu_brut as salariu_brut,
        v_salariu_net as salariu_net,
        ROUND((v_total_sporuri / v_salariu_baza) * 100, 2) as procent_sporuri,
        ROUND((v_total_penalizari / v_salariu_baza) * 100, 2) as procent_penalizari;
END$

DELIMITER ;

-- -----------------------------------------------------
-- INSERARE DATE TEST în tabelul de log (opțional)
-- -----------------------------------------------------
INSERT INTO log_activitati_simple (id_user, id_target, actiune, descriere, tabel_afectat, ip_address) VALUES
(1, NULL, 'SYSTEM_START', 'Sistem de dosare angajați inițializat', 'sistem', '127.0.0.1'),
(1, 1, 'VIEW_DOSSIER', 'Vizualizare dosar angajat Vasile Fabian', 'useri', '192.168.1.100'),
(1, 6, 'VIEW_DOSSIER', 'Vizualizare dosar angajat Cosmina Capra', 'useri', '192.168.1.100');

-- Reactivează constrângerile FOREIGN KEY
SET FOREIGN_KEY_CHECKS = 1;

-- 4. Creare triggeri
-- -----------------------------------------------------
-- Trigger care deasigneaza toti angajatii dintr-un departament care urmeaza sa fie sters
-- -----------------------------------------------------
DELIMITER $$
DROP TRIGGER IF EXISTS before_dep_deleted $$
USE test$$
CREATE
TRIGGER test.before_dep_deleted
BEFORE DELETE ON test.departament
FOR EACH ROW
BEGIN
    UPDATE useri SET id_dep = -1 WHERE id_dep = OLD.id_dep;
END$$

-- -----------------------------------------------------
-- Trigger care seteaza numarul de zile de concedii in functie de tipul de user
-- -----------------------------------------------------
USE test$$
DROP TRIGGER IF EXISTS after_ins $$

USE test$$
CREATE
DEFINER=root@localhost
TRIGGER test.after_ins
BEFORE INSERT ON test.useri
FOR EACH ROW
BEGIN
    SET NEW.zilecons = 0;
    SET NEW.conluate = 0;
    SET NEW.conramase = 3;
    IF NEW.tip = 2 THEN
        SET NEW.zileramase = 30;
    ELSE
        SET NEW.zileramase = 40;
    END IF;
END$$

USE test$$
DROP TRIGGER IF EXISTS after_mod $$

USE test$$
CREATE
DEFINER=root@localhost
TRIGGER test.after_mod
BEFORE UPDATE ON test.useri
FOR EACH ROW
BEGIN
    IF NEW.tip = 2 and new.tip != old.tip THEN
        SET NEW.zileramase = 30;
    ELSE 
		if new.tip != old.tip and new.tip != 2 then
			SET NEW.zileramase = 40;
		END IF;
    END IF;
END$$

DELIMITER $$
DROP TRIGGER IF EXISTS after_user_insert$$
CREATE TRIGGER after_user_insert
AFTER INSERT ON useri
FOR EACH ROW
BEGIN
    IF NOT EXISTS (SELECT 1 FROM teme WHERE id_usr = NEW.id) THEN
        INSERT INTO teme (id_usr) VALUES (NEW.id);
    END IF;
END$$

DROP TRIGGER IF EXISTS aftrdel $$
USE test$$
CREATE
DEFINER=root@localhost
TRIGGER test.aftrdel
BEFORE DELETE ON test.useri
FOR EACH ROW
BEGIN
    delete from concedii where id_ang = old.id;
END$$

USE test$$
DROP TRIGGER IF EXISTS before_insert_useri $$

USE test$$
CREATE
DEFINER=root@localhost
TRIGGER test.before_insert_useri
BEFORE INSERT ON test.useri
FOR EACH ROW
BEGIN
    SET NEW.zilecons = 0;
    SET NEW.conluate = 0;
    SET NEW.conramase = 3;
    SET NEW.zileramase = IF(NEW.tip = 2, 30, 40);
END$$

USE test$$
DROP TRIGGER IF EXISTS before_user_deleted $$

USE test$$
CREATE
DEFINER=root@localhost
TRIGGER test.before_user_deleted
BEFORE DELETE ON test.useri
FOR EACH ROW
BEGIN
    DELETE FROM concedii WHERE id_ang = OLD.id;
END$$

USE test$$
DROP TRIGGER IF EXISTS teme1 $$

USE test$$
CREATE
DEFINER=root@localhost
TRIGGER test.teme1
AFTER INSERT ON test.useri
FOR EACH ROW
BEGIN
    INSERT INTO teme (id_usr) VALUES (NEW.id);
END$$

USE test$$
DROP TRIGGER IF EXISTS teme2 $$

USE test$$
CREATE
DEFINER=root@localhost
TRIGGER test.teme2
BEFORE DELETE ON test.useri
FOR EACH ROW
BEGIN
    delete from teme where id_usr = old.id;
END$$

-- -----------------------------------------------------
-- Trigger care modifica zilele si numarul de concedii dupa ce un concediu e sters
-- -----------------------------------------------------
DROP TRIGGER IF EXISTS after_delete $$
CREATE TRIGGER after_delete
AFTER DELETE ON concedii
FOR EACH ROW
BEGIN
    DECLARE userType INT;
    DECLARE userHierarchy INT;
    DECLARE totalDurata INT;
    DECLARE concediiAnCurent INT;
    
    -- Obține tipul și ierarhia utilizatorului
    SELECT tip, (SELECT ierarhie FROM tipuri WHERE tip = useri.tip) 
    INTO userType, userHierarchy 
    FROM useri 
    WHERE id = OLD.id_ang;
    
    -- Calculează durata totală a concediilor pentru anul curent
    SELECT COALESCE(SUM(durata), 0) INTO totalDurata 
    FROM concedii 
    WHERE id_ang = OLD.id_ang 
      AND status >= 0
      AND YEAR(start_c) = YEAR(CURDATE());
    
    -- Calculează numărul de concedii pentru anul curent
    SELECT COUNT(*) INTO concediiAnCurent 
    FROM concedii 
    WHERE id_ang = OLD.id_ang 
      AND status >= 0
      AND YEAR(start_c) = YEAR(CURDATE());
    
    -- Actualizează utilizatorul cu valorile calculate
    UPDATE useri
    SET zilecons = totalDurata,
        zileramase = IF(userHierarchy = 10, 30 - totalDurata, 40 - totalDurata),
        conluate = concediiAnCurent,
        conramase = 3 - concediiAnCurent
    WHERE id = OLD.id_ang;
END$$

-- -----------------------------------------------------
-- Trigger care calculează zilele și numărul de concedii după ce un concediu este adăugat
-- -----------------------------------------------------
DROP TRIGGER IF EXISTS after_insert $$
CREATE TRIGGER after_insert
AFTER INSERT ON concedii
FOR EACH ROW
BEGIN
    DECLARE userType INT;
    DECLARE userHierarchy INT;
    DECLARE totalDurata INT;
    DECLARE concediiAnCurent INT;
    
    -- Obține tipul și ierarhia utilizatorului
    SELECT tip, (SELECT ierarhie FROM tipuri WHERE tip = useri.tip) 
    INTO userType, userHierarchy 
    FROM useri 
    WHERE id = NEW.id_ang;
    
    -- Calculează durata totală a concediilor pentru anul curent
    SELECT COALESCE(SUM(durata), 0) INTO totalDurata 
    FROM concedii 
    WHERE id_ang = NEW.id_ang 
      AND status >= 0
      AND YEAR(start_c) = YEAR(CURDATE());
    
    -- Calculează numărul de concedii pentru anul curent
    SELECT COUNT(*) INTO concediiAnCurent 
    FROM concedii 
    WHERE id_ang = NEW.id_ang 
      AND status >= 0
      AND YEAR(start_c) = YEAR(CURDATE());
    
    -- Actualizează utilizatorul cu valorile calculate
    UPDATE useri
    SET zilecons = totalDurata,
        zileramase = IF(userHierarchy = 10, 30 - totalDurata, 40 - totalDurata),
        conluate = concediiAnCurent,
        conramase = 3 - concediiAnCurent
    WHERE id = NEW.id_ang;
END$$

-- -----------------------------------------------------
-- Trigger care modifica numarul de concedii dupa ce un concediu este adaugat
-- -----------------------------------------------------
DROP TRIGGER IF EXISTS after_insert2 $$
CREATE TRIGGER after_insert2
AFTER INSERT ON concedii
FOR EACH ROW
BEGIN
    -- Acest trigger a fost înlocuit cu funcționalitatea din after_insert
    -- Păstrat gol pentru compatibilitate, dar funcționalitatea este unificată în after_insert
END$$

-- -----------------------------------------------------
-- Trigger care modifica numarul de zile de concedii dupa ce se modifica un concediu
-- -----------------------------------------------------
DROP TRIGGER IF EXISTS after_update $$
CREATE TRIGGER after_update
AFTER UPDATE ON concedii
FOR EACH ROW
BEGIN
    DECLARE userType INT;
    DECLARE userHierarchy INT;
    DECLARE totalDurata INT;
    DECLARE concediiAnCurent INT;
    
    -- Obține tipul și ierarhia utilizatorului
    SELECT tip, (SELECT ierarhie FROM tipuri WHERE tip = useri.tip) 
    INTO userType, userHierarchy 
    FROM useri 
    WHERE id = NEW.id_ang;
    
    -- Calculează durata totală a concediilor pentru anul curent
    SELECT COALESCE(SUM(durata), 0) INTO totalDurata 
    FROM concedii 
    WHERE id_ang = NEW.id_ang 
      AND status >= 0
      AND YEAR(start_c) = YEAR(CURDATE());
    
    -- Calculează numărul de concedii pentru anul curent
    SELECT COUNT(*) INTO concediiAnCurent 
    FROM concedii 
    WHERE id_ang = NEW.id_ang 
      AND status >= 0
      AND YEAR(start_c) = YEAR(CURDATE());
    
    -- Actualizează utilizatorul cu valorile calculate
    UPDATE useri
    SET zilecons = totalDurata,
        zileramase = IF(userHierarchy = 10, 30 - totalDurata, 40 - totalDurata),
        conluate = concediiAnCurent,
        conramase = 3 - concediiAnCurent
    WHERE id = NEW.id_ang;
END$$

-- -----------------------------------------------------
-- Trigger care adauga durata unui concediu, atunci cand e adaugat
-- -----------------------------------------------------
DROP TRIGGER IF EXISTS afterinsert $$
CREATE
TRIGGER test.afterinsert
BEFORE INSERT ON test.concedii
FOR EACH ROW
BEGIN
    SET NEW.durata = DATEDIFF(NEW.end_c, NEW.start_c) + 1;
END$$

-- -----------------------------------------------------
-- Trigger care verifică regulile la inserarea unui concediu
-- -----------------------------------------------------
DROP TRIGGER IF EXISTS before_insert_concedii $$
CREATE TRIGGER before_insert_concedii
BEFORE INSERT ON concedii
FOR EACH ROW
BEGIN
    DECLARE userType INT;
    DECLARE userHierarchy INT;
    DECLARE concediiAnCurent INT;
    DECLARE concediiVara INT;
    DECLARE totalDurata INT;
    
    -- Verifică dacă data de final nu este înaintea celei de început
    IF NEW.end_c < NEW.start_c THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Data de final nu poate fi inaintea celei de inceput.';
    END IF;
    
    -- Calculează durata concediului
    SET NEW.durata = DATEDIFF(NEW.end_c, NEW.start_c) + 1;
    
    -- Setează datele
    SET NEW.added = CURDATE();
    SET NEW.modified = CURDATE();
    SET NEW.acc_res = CURDATE();
    
    -- Obține tipul și ierarhia utilizatorului
    SELECT tip, (SELECT ierarhie FROM tipuri WHERE tip = useri.tip) 
    INTO userType, userHierarchy 
    FROM useri 
    WHERE id = NEW.id_ang;
    
    -- Verifică numărul de concedii din anul curent
    SELECT COUNT(*) INTO concediiAnCurent 
    FROM concedii 
    WHERE id_ang = NEW.id_ang 
      AND status >= 0
      AND YEAR(start_c) = YEAR(NEW.start_c);
    
    -- Verifică numărul de concedii din vara curentă
    SELECT COUNT(*) INTO concediiVara 
    FROM concedii 
    WHERE id_ang = NEW.id_ang 
      AND status >= 0
      AND YEAR(start_c) = YEAR(NEW.start_c)
      AND (
          (start_c BETWEEN STR_TO_DATE(CONCAT(YEAR(NEW.start_c), '-06-01'), '%Y-%m-%d') 
                        AND STR_TO_DATE(CONCAT(YEAR(NEW.start_c), '-08-31'), '%Y-%m-%d'))
          OR 
          (end_c BETWEEN STR_TO_DATE(CONCAT(YEAR(NEW.start_c), '-06-01'), '%Y-%m-%d') 
                      AND STR_TO_DATE(CONCAT(YEAR(NEW.start_c), '-08-31'), '%Y-%m-%d'))
          OR 
          (start_c <= STR_TO_DATE(CONCAT(YEAR(NEW.start_c), '-06-01'), '%Y-%m-%d') 
           AND end_c >= STR_TO_DATE(CONCAT(YEAR(NEW.start_c), '-08-31'), '%Y-%m-%d'))
      );
    
    -- Verifică dacă noul concediu ar fi în perioada de vară
    IF (NEW.start_c BETWEEN STR_TO_DATE(CONCAT(YEAR(NEW.start_c), '-06-01'), '%Y-%m-%d') 
                        AND STR_TO_DATE(CONCAT(YEAR(NEW.start_c), '-08-31'), '%Y-%m-%d'))
       OR 
       (NEW.end_c BETWEEN STR_TO_DATE(CONCAT(YEAR(NEW.start_c), '-06-01'), '%Y-%m-%d') 
                     AND STR_TO_DATE(CONCAT(YEAR(NEW.start_c), '-08-31'), '%Y-%m-%d'))
       OR 
       (NEW.start_c <= STR_TO_DATE(CONCAT(YEAR(NEW.start_c), '-06-01'), '%Y-%m-%d') 
        AND NEW.end_c >= STR_TO_DATE(CONCAT(YEAR(NEW.start_c), '-08-31'), '%Y-%m-%d')) THEN
        
        -- Verifică dacă există deja un concediu de vară
        IF concediiVara > 0 THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Nu este permis mai mult de un concediu în perioada de vară (1 iunie - 31 august).';
        END IF;
    END IF;
    
    -- Verifică regula de maxim 3 concedii pe an
    IF concediiAnCurent >= 3 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Angajatul a atins deja limita de 3 concedii pentru anul curent.';
    END IF;
    
    -- Calculează durata totală a concediilor din anul curent
    SELECT COALESCE(SUM(durata), 0) INTO totalDurata 
    FROM concedii 
    WHERE id_ang = NEW.id_ang 
      AND status >= 0
      AND YEAR(start_c) = YEAR(NEW.start_c);
    
    -- Verifică dacă se depășește limita de zile în funcție de ierarhie
    IF userHierarchy = 10 AND (totalDurata + NEW.durata > 30) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Angajații începători pot avea maxim 30 de zile de concediu pe an.';
    ELSEIF userHierarchy != 10 AND (totalDurata + NEW.durata > 40) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Angajații pot avea maxim 40 de zile de concediu pe an.';
    END IF;
END$$

-- -----------------------------------------------------
-- Trigger care verifică regulile la actualizarea unui concediu
-- -----------------------------------------------------
DROP TRIGGER IF EXISTS before_update_concedii $$
CREATE TRIGGER before_update_concedii
BEFORE UPDATE ON concedii
FOR EACH ROW
BEGIN
    DECLARE userType INT;
    DECLARE userHierarchy INT;
    DECLARE concediiAnCurent INT;
    DECLARE concediiVara INT;
    DECLARE totalDurata INT;
    
    -- Verifică dacă data de final nu este înaintea celei de început (doar dacă s-au modificat datele)
    IF NEW.end_c < NEW.start_c AND (OLD.start_c != NEW.start_c OR OLD.end_c != NEW.end_c) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Data de final nu poate fi inaintea celei de inceput.';
    END IF;
    
    -- Dacă s-au modificat datele, recalculează durata
    IF OLD.start_c != NEW.start_c OR OLD.end_c != NEW.end_c THEN
        SET NEW.durata = DATEDIFF(NEW.end_c, NEW.start_c) + 1;
    END IF;
    
    -- Dacă statusul este negativ, setează durata la 0
    IF NEW.status < 0 THEN
        SET NEW.durata = 0;
    END IF;
    
    -- Dacă statusul s-a schimbat, setează data modificării
    IF NEW.status != OLD.status THEN
        SET NEW.modified = CURDATE();
    END IF;
    
    -- Dacă s-au modificat datele sau statusul și statusul nou este >= 0, verifică regulile
    IF (OLD.start_c != NEW.start_c OR OLD.end_c != NEW.end_c OR OLD.status != NEW.status) AND NEW.status >= 0 THEN
        -- Obține tipul și ierarhia utilizatorului
        SELECT tip, (SELECT ierarhie FROM tipuri WHERE tip = useri.tip) 
        INTO userType, userHierarchy 
        FROM useri 
        WHERE id = NEW.id_ang;
        
        -- Verifică numărul de concedii din anul curent (excluzând pe cel curent)
        SELECT COUNT(*) INTO concediiAnCurent 
        FROM concedii 
        WHERE id_ang = NEW.id_ang 
          AND id != NEW.id
          AND status >= 0
          AND YEAR(start_c) = YEAR(NEW.start_c);
        
        -- Adaugă 1 pentru concediul curent dacă statusul este >= 0
        IF NEW.status >= 0 THEN
            SET concediiAnCurent = concediiAnCurent + 1;
        END IF;
        
        -- Verifică regula de maxim 3 concedii pe an
        IF concediiAnCurent > 3 THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Angajatul a atins deja limita de 3 concedii pentru anul curent.';
        END IF;
        
        -- Verifică numărul de concedii din vara curentă (excluzând pe cel curent)
        SELECT COUNT(*) INTO concediiVara 
        FROM concedii 
        WHERE id_ang = NEW.id_ang 
          AND id != NEW.id
          AND status >= 0
          AND YEAR(start_c) = YEAR(NEW.start_c)
          AND (
              (start_c BETWEEN STR_TO_DATE(CONCAT(YEAR(NEW.start_c), '-06-01'), '%Y-%m-%d') 
                         AND STR_TO_DATE(CONCAT(YEAR(NEW.start_c), '-08-31'), '%Y-%m-%d'))
              OR 
              (end_c BETWEEN STR_TO_DATE(CONCAT(YEAR(NEW.start_c), '-06-01'), '%Y-%m-%d') 
                         AND STR_TO_DATE(CONCAT(YEAR(NEW.start_c), '-08-31'), '%Y-%m-%d'))
              OR 
              (start_c <= STR_TO_DATE(CONCAT(YEAR(NEW.start_c), '-06-01'), '%Y-%m-%d') 
               AND end_c >= STR_TO_DATE(CONCAT(YEAR(NEW.start_c), '-08-31'), '%Y-%m-%d'))
          );
        
        -- Verifică dacă concediul actualizat ar fi în perioada de vară
        IF (NEW.start_c BETWEEN STR_TO_DATE(CONCAT(YEAR(NEW.start_c), '-06-01'), '%Y-%m-%d') 
                         AND STR_TO_DATE(CONCAT(YEAR(NEW.start_c), '-08-31'), '%Y-%m-%d'))
           OR 
           (NEW.end_c BETWEEN STR_TO_DATE(CONCAT(YEAR(NEW.start_c), '-06-01'), '%Y-%m-%d') 
                        AND STR_TO_DATE(CONCAT(YEAR(NEW.start_c), '-08-31'), '%Y-%m-%d'))
           OR 
           (NEW.start_c <= STR_TO_DATE(CONCAT(YEAR(NEW.start_c), '-06-01'), '%Y-%m-%d') 
            AND NEW.end_c >= STR_TO_DATE(CONCAT(YEAR(NEW.start_c), '-08-31'), '%Y-%m-%d')) THEN
            
            -- Verifică dacă există deja un concediu de vară (altul decât cel curent)
            IF concediiVara > 0 THEN
                SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Nu este permis mai mult de un concediu în perioada de vară (1 iunie - 31 august).';
            END IF;
        END IF;
        
        -- Calculează durata totală a concediilor din anul curent (excluzând pe cel curent)
        SELECT COALESCE(SUM(durata), 0) INTO totalDurata 
        FROM concedii 
        WHERE id_ang = NEW.id_ang 
          AND id != NEW.id
          AND status >= 0
          AND YEAR(start_c) = YEAR(NEW.start_c);
        
        -- Adaugă durata concediului curent dacă statusul este >= 0
        IF NEW.status >= 0 THEN
            SET totalDurata = totalDurata + NEW.durata;
        END IF;
        
        -- Verifică dacă se depășește limita de zile în funcție de ierarhie
        IF userHierarchy = 10 AND totalDurata > 30 THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Angajații începători pot avea maxim 30 de zile de concediu pe an.';
        ELSEIF userHierarchy != 10 AND totalDurata > 40 THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Angajații pot avea maxim 40 de zile de concediu pe an.';
        END IF;
    END IF;
END$$

-- -----------------------------------------------------
-- Trigger care calculeaza zilele si numarul de concedii, dupa ce un concediu e respins
-- -----------------------------------------------------
DROP TRIGGER IF EXISTS negativestatus $$
CREATE TRIGGER negativestatus
BEFORE UPDATE ON concedii
FOR EACH ROW
BEGIN
    -- Dacă statusul se schimbă la negativ, resetează durata și actualizează contoarele
    IF NEW.status < 0 AND OLD.status >= 0 THEN
        SET NEW.durata = 0;
    END IF;
END$$

-- -----------------------------------------------------
-- Trigger care calculeaza zilele si numarul de concedii, dupa ce un concediu e aprobat final
-- -----------------------------------------------------
DROP TRIGGER IF EXISTS status2 $$
CREATE TRIGGER status2
BEFORE UPDATE ON concedii
FOR EACH ROW
BEGIN
    -- Acest trigger este redundant acum deoarece after_update gestionează deja toate situațiile
    -- Păstrat gol pentru compatibilitate
END$$

-- -----------------------------------------------------
-- END ZONA TRIGGERI
-- -----------------------------------------------------
DELIMITER ;

-- 5. Inserarea datelor initiale
-- -----------------------------------------------------
-- INSERARI
-- -----------------------------------------------------
-- Dezactivează constrângerile FOREIGN KEY pentru a evita problemele la inserare
SET FOREIGN_KEY_CHECKS = 0;

-- Inserarea datelor inițiale despre departamente
INSERT INTO departament (id_dep, nume_dep) VALUES
(1, 'HR'),
(2, 'Finante'),
(3, 'IT'),
(4, 'Juridic'),
(5, 'Marketing'),
(6, 'Vanzari'),
(7, 'Logistica'),
(8, 'Productie'),
(9, 'Achizitii'),
(10, 'Cercetare si Dezvoltare'),
(11, 'Customer Support'),
(12, 'Administrativ'),
(13, 'Comunicare'),
(14, 'Training'),
(15, 'Security'),
(16, 'Management'),
(17, 'Business Intelligence'),
(18, 'Contabilitate'),
(19, 'Control Intern'),
(20, 'Servicii Generale');
-- Inserarea datelor inițiale despre tipuri de angajati
INSERT INTO tipuri (tip, denumire, salariu, ierarhie, descriere, departament_specific) VALUES 
(0, 'Director', 13000, 2, 'Director de departament', 20),
(1, 'New Graduate', 3500, 10, 'Angajat nou, fără experiență', 20),
(2, 'Intern', 3000, 11, 'Stagiar', 20),
(3, 'Sef', 11600, 4, 'Șef de echipă/departament', 20),
(4, 'CEO', 26000, 1, 'Director General', 16), -- Management = 16
(5, 'Junior', 4500, 9, 'Angajat junior', 20),
(6, 'lvl1', 5500, 8, 'Nivel 1 de experiență', 20),
(7, 'lvl2', 6500, 7, 'Nivel 2 de experiență', 20),
(8, 'Mid', 7500, 6, 'Angajat cu experiență medie', 20),
(9, 'Senior', 8900, 5, 'Angajat cu experiență avansată', 20),
(10, 'Manager', 9200, 4, 'Manager de departament/echipă', 20),
(11, 'Principal', 11300, 3, 'Manager principal', 20),
(12, 'Vice Presedinte', 16000, 2, 'Vice Președinte', 16), -- Management = 16
(13, 'Vice Presedinte Senior', 18000, 2, 'Vice Președinte Senior', 16), -- Management = 16
(15, 'MP', 20000, 1, 'Managing Partner', 16), -- Management = 16
(16, 'DC', 22000, 1, 'Director de Conformitate', 4), -- Juridic = 4
(17, 'CHRO', 24000, 1, 'Director Resurse Umane', 1), -- HR = 1
(18, 'CFO', 26000, 1, 'Director Financiar', 2), -- Finante = 2
(19, 'COO', 26000, 1, 'Director Operațional', 16); -- Management = 16

-- Nivel Director
INSERT INTO tipuri (tip, denumire, salariu, ierarhie, descriere, departament_specific) VALUES
(22, 'Director General', 30000, 1, 'Director General', 16), -- Management = 16
(23, 'Director', 25000, 2, 'Director de departament', 20),
(24, 'Director Adjunct', 20000, 3, 'Director adjunct de departament', 20);

-- Nivel Management
INSERT INTO tipuri (tip, denumire, salariu, ierarhie, descriere, departament_specific) VALUES
(25, 'Manager', 15000, 4, 'Manager de echipă/departament', 20),
(26, 'Coordonator', 12000, 5, 'Coordonator de activități', 20),
(27, 'Responsabil', 10000, 6, 'Responsabil de domeniu/activitate', 20);

-- Nivel Specialist
INSERT INTO tipuri (tip, denumire, salariu, ierarhie, descriere, departament_specific) VALUES
(28, 'Specialist Senior', 9000, 7, 'Specialist senior în domeniu', 20),
(29, 'Specialist', 7000, 8, 'Specialist în domeniu', 20),
(30, 'Analist Senior', 8500, 7, 'Analist senior în domeniu', 2), -- Finante = 2
(31, 'Analist', 6500, 8, 'Analist în domeniu', 2), -- Finante = 2
(32, 'Consultant Senior', 8000, 7, 'Consultant senior în domeniu', 20),
(33, 'Consultant', 6000, 8, 'Consultant în domeniu', 20);

-- Nivel Execuție
INSERT INTO tipuri (tip, denumire, salariu, ierarhie, descriere, departament_specific) VALUES
(34, 'Administrator', 5500, 9, 'Administrator în domeniu', 3), -- IT = 3
(35, 'Asistent', 4500, 10, 'Asistent administrativ/operațional', 20),
(36, 'Inginer', 7500, 8, 'Inginer în domeniu tehnic', 3), -- IT = 3
(37, 'Tehnician', 5000, 9, 'Tehnician în domeniu', 3), -- IT = 3
(38, 'Operator', 4000, 10, 'Operator în domeniu', 20);

-- Tabel sporuri
INSERT INTO tipuri_sporuri (id, denumire, procent) VALUES
(0, 'Niciun spor', 0),
(1, 'Spor de noapte', 25),
(2, 'Spor de weekend', 15),
(3, 'Spor de vechime', 10),
(4, 'Spor de toxicitate', 20),
(5, 'Spor de confidentialitate', 10),
(6, 'Spor de periculozitate', 15),
(7, 'Spor pentru ore suplimentare', 75);

-- Tabel penalizari
INSERT INTO tipuri_penalizari (id, denumire, procent) VALUES
(1, 'Intarzieri repetate', 10),
(2, 'Absent nemotivat', 20),
(3, 'Nerespectare regulament', 15),
(4, 'Pagube materiale', 30);

-- Inserarea datelor inițiale despre status concediu
INSERT INTO statusuri (status, nume_status) VALUES 
(-2, 'Dezaprobat director'),
(-1, 'Dezaprobat sef'),
(0, 'Neaprobat'),
(1, 'Aprobat sef'),
(2, 'Aprobat director');

-- Tabel statusuri2
INSERT INTO statusuri2 (id, procent) VALUES
(0, 0),
(1, 25),
(2, 50),
(3, 75),
(4, 100);

-- Tabel cicluri
INSERT INTO cicluri (id, semnificatie) VALUES
(1, 'liceal'),
(2, 'post-liceal'),
(3, 'licenta'),
(4, 'masterat'),
(5, 'doctorat'),
(6, 'post-doc');

-- Tabel limbi
INSERT INTO limbi (id, limba) VALUES
(1, 'romana'),
(2, 'engleza'),
(3, 'franceza'),
(4, 'germana'),
(5, 'spaniola'),
(6, 'italiana'),
(7, 'olandeza'),
(8, 'japoneza');

-- Tabel nivel
INSERT INTO nivel (id, semnificatie) VALUES
(1, 'A1'),
(2, 'A2'),
(3, 'B1'),
(4, 'B2'),
(5, 'C1'),
(6, 'C2');

-- Tabel tip_job
INSERT INTO tip_job (id, semnificatie) VALUES
(1, 'fizic'),
(2, 'hibrid'),
(3, 'remote');

-- Tabel tip_adev
INSERT INTO tip_adev (id, denumire) VALUES
(1, 'adeverinta salariat'),
(2, 'adeverinta venit'),
(3, 'adeverinta medicala'),
(4, 'adeverinta concediu'),
(5, 'adeverinta experienta'),
(6, 'adeverinta delegare'),
(7, 'adeverinta somaj'),
(8, 'adeverinta carte de munca'),
(9, 'adeverinta cursuri'),
(10, 'adeverinta participare proiect'),
(11, 'adeverinta stagiu practica'),
(12, 'adeverinta incetare contract'),
(13, 'adeverinta vechime cumulata'),
(14, 'adeverinta pentru pensie'),
(15, 'adeverinta pentru banca/credit'),
(16, 'adeverinta pentru locuinta'),
(17, 'adeverinta pentru grad de handicap'),
(18, 'adeverinta pentru crese/gradinite'),
(19, 'adeverinta COVID-19 carantina'),
(20, 'adeverinta indemnizatie crestere copil');

-- Inserarea datelor inițiale despre tipuri de concedii
INSERT INTO tipcon (motiv, nr_zile) VALUES
('Concediu odihna', 21),
('Concediu formare profesionala', 30),
('Concediu medical', 90),
('Concediu risc maternal', 126),
('Concediu maternitate', 126),
('Concediu paternal', 5),
('Concediu crestere copil', 730),
('Concediu pentru ingrijirea copilului bolnav', 45),
('Concediu fara plata', 30),
('Concediu pentru evenimente familiale', 5),
('Concediu pentru studii', 30),
('Concediu pentru donare de sange', 2),
('Concediu pentru activitati de voluntariat', 5),
('Concediu pentru forta majora', 5),
('Concediu pentru carantina', 14);

-- Date inițiale pentru sediul principal
INSERT INTO sedii (nume_sediu, tip_sediu, strada, cod, oras, judet, tara, latitudine, longitudine, telefon, email) VALUES
('Sediu Central', 'principal', 'Soseaua Giurgiului nr. 269', '040666', 'București', '4', 'România', 44.3749622, 26.0883728, '021-123-4567', 'contact@companie.ro'),
('Sediu Secundar', 'secundar', 'Strada Locotent Stancu Ion nr. 35', '130105', 'Targoviste', 'Dambovita', 'România', 44.9202398, 25.4640106, '0264-123-456', 'cluj@companie.ro');

-- Dezactivează constrângerile FOREIGN KEY pentru a evita problemele la inserare
SET FOREIGN_KEY_CHECKS = 0;

-- Șterge triggerii care creează conflictul
DROP TRIGGER IF EXISTS teme1;
DROP TRIGGER IF EXISTS teme2;
DROP TRIGGER IF EXISTS after_user_insert;

-- Șterge toate datele din teme înainte de a insera noile date
TRUNCATE TABLE teme;

-- Inserarea useri (fără id_echipa inițial)
INSERT INTO useri (nume, prenume, data_nasterii, email, telefon, username, password, id_dep, tip, adresa, culoare, cnp, data_ang) VALUES 
('Vasile', 'Fabian', '1996-09-19', 'vasile.fabian@example.com', '0700000000', 'fvasile', '$2a$10$gPdSQ5MuTzI7K1vaHDXVhOyk19Mehd.gZO42NvN/MZmLTfJ8kezoq', 1, 0, 'Strada Unirii', '#3A8DFF', '1960919123456', '2020-01-15'),
('Popescu', 'Maria', '2001-12-28', 'maria.popescu2812@example.com', '0787763178', 'mariap', '$2a$10$gPdSQ5MuTzI7K1vaHDXVhOyk19Mehd.gZO42NvN/MZmLTfJ8kezoq', 1, 1, 'Strada Libertății', '#FF5733', '2011228123456', '2021-03-10'),
('Girnita', 'Claudia', '2002-04-18', 'claudia.girnita@example.com', '0771000002', 'claudia.g', '$2a$10$gPdSQ5MuTzI7K1vaHDXVhOyk19Mehd.gZO42NvN/MZmLTfJ8kezoq', 1, 2,'Strada Unirii', '#42E695', '2020418123456', '2022-05-20'),
('Costache', 'Irina', '2003-05-19', 'irina.costache@example.com', '0700000001', 'irina.c', '$2a$10$gPdSQ5MuTzI7K1vaHDXVhOyk19Mehd.gZO42NvN/MZmLTfJ8kezoq', 1, 3,'Strada Basarab', '#9B59B6', '2030519123456', '2022-01-05'),
('Moise', 'Monica', '2002-05-07', 'monica.moise@example.com', '0736000003', 'monica.m', '$2a$10$gPdSQ5MuTzI7K1vaHDXVhOyk19Mehd.gZO42NvN/MZmLTfJ8kezoq', 1, 34,'Strada Libertății', '#FFD700', '2020507123456', '2021-10-15'),
('Capra', 'Cosmina', '2002-03-01', 'cosmina.capra@example.com', '0700000004', 'cosmina.c', '$2a$10$gPdSQ5MuTzI7K1vaHDXVhOyk19Mehd.gZO42NvN/MZmLTfJ8kezoq', 2, 0, 'Strada Doamnei', '#E74C3C', '2020301123456', '2020-04-01'),
('Muedin', 'Emin', '1995-10-04', 'emin.m@example.com', '0700000005', 'emin.m', '$2a$10$gPdSQ5MuTzI7K1vaHDXVhOyk19Mehd.gZO42NvN/MZmLTfJ8kezoq', 2, 1, 'Strada Doamnei', '#1ABC9C', '1951004123456', '2019-11-01'),
('Rebreanu', 'Andrei', '2003-07-07', 'andrei.rebreanu@example.com', '0700000006', 'andrei.rebreanu', '$2a$10$gPdSQ5MuTzI7K1vaHDXVhOyk19Mehd.gZO42NvN/MZmLTfJ8kezoq', 2, 2, 'Strada Frunzei', '#F39C12', '2030707123456', '2023-01-10'),
('Ionescu', 'Lucian', '1989-04-18', 'lucion@example.com', '0700000007', 'lucian.i', '$2a$10$gPdSQ5MuTzI7K1vaHDXVhOyk19Mehd.gZO42NvN/MZmLTfJ8kezoq', 2, 3, 'Strada Alunului', '#8E44AD', '1890418123456', '2018-06-15'),
('Ciucioiu', 'Elena', '2002-09-11', 'elena.c@example.com', '0700000008', 'elena.c', '$2a$10$gPdSQ5MuTzI7K1vaHDXVhOyk19Mehd.gZO42NvN/MZmLTfJ8kezoq', 2, 4, 'Strada Izvorului', '#2ECC71', '2020911123456', '2021-07-01');

-- Adaugăm utilizatori pentru departamentul IT
INSERT INTO useri (nume, prenume, data_nasterii, email, telefon, username, password, id_dep, tip, adresa, culoare, cnp, data_ang) VALUES 
('Dumitrescu', 'Adrian', '1990-04-15', 'adrian.dumitrescu@example.com', '0712345678', 'adumitrescu', '$2a$10$gPdSQ5MuTzI7K1vaHDXVhOyk19Mehd.gZO42NvN/MZmLTfJ8kezoq', 3, 23, 'Strada Primăverii 10', '#4285F4', '1900415123456', '2018-03-01'),
('Popa', 'Mihai', '1992-08-23', 'mihai.popa@example.com', '0723456789', 'mpopa', '$2a$10$gPdSQ5MuTzI7K1vaHDXVhOyk19Mehd.gZO42NvN/MZmLTfJ8kezoq', 3, 36, 'Bulevardul Decebal 25', '#34A853', '1920823123456', '2019-05-15'),
('Stanciu', 'Diana', '1995-02-10', 'diana.stanciu@example.com', '0734567890', 'dstanciu', '$2a$10$gPdSQ5MuTzI7K1vaHDXVhOyk19Mehd.gZO42NvN/MZmLTfJ8kezoq', 3, 31, 'Strada Victoriei 7', '#EA4335', '2950210123456', '2020-10-01'),
('Barbu', 'Alexandru', '1988-11-30', 'alexandru.barbu@example.com', '0745678901', 'abarbu', '$2a$10$gPdSQ5MuTzI7K1vaHDXVhOyk19Mehd.gZO42NvN/MZmLTfJ8kezoq', 3, 34, 'Aleea Castanilor 3', '#FBBC05', '1881130123456', '2017-08-20'),
('Dobre', 'Cristina', '1993-06-18', 'cristina.dobre@example.com', '0756789012', 'cdobre', '$2a$10$gPdSQ5MuTzI7K1vaHDXVhOyk19Mehd.gZO42NvN/MZmLTfJ8kezoq', 3, 36, 'Strada Nucului 15', '#7B1FA2', '2930618123456', '2021-02-15');

-- Inserează manual în teme pentru fiecare utilizator
INSERT INTO teme (id_usr, accent, clr, sidebar, card, text, hover) 
SELECT id, '#10439F', '#d8d9e1', '#ECEDFA', '#ECEDFA', '#333', '#ECEDFA' 
FROM useri;

-- Update specific pentru teme
UPDATE teme SET accent="#C8BFE7" WHERE id_usr = 14;
UPDATE teme SET accent="#C63C51", clr="#1a1a1a", sidebar="#2a2a2a", card="#2a2a2a", hover="#2a2a2a", text="#ececec" WHERE id_usr=15;

-- Creează un nou trigger pentru inserări viitoare
DELIMITER $$
CREATE TRIGGER after_user_insert
AFTER INSERT ON useri
FOR EACH ROW
BEGIN
    IF NOT EXISTS (SELECT 1 FROM teme WHERE id_usr = NEW.id) THEN
        INSERT INTO teme (id_usr) VALUES (NEW.id);
    END IF;
END$$
DELIMITER ;

-- Adaugăm proiecte
INSERT INTO proiecte (nume, descriere, start, end, supervizor) VALUES
('ERP Implementation', 'Implementarea unui sistem ERP pentru gestionarea resurselor companiei', '2025-01-01', '2025-12-31', 11),
('Website Redesign', 'Reproiectarea site-ului web al companiei pentru o experiență mai bună a utilizatorilor', '2025-03-15', '2023-08-31', 12),
('Mobile App Development', 'Dezvoltarea unei aplicații mobile pentru clienți', '2025-04-01', '2025-10-31', 13),
('HR Management System', 'Dezvoltarea unui sistem intern pentru managementul resurselor umane', '2025-02-01', '2025-07-31', 14),
('Customer Support Portal', 'Crearea unui portal de asistență pentru clienți', '2023-05-01', '2023-11-30', 15);

-- Adăugăm echipe
INSERT INTO echipe (nume, supervizor, id_prj) VALUES
('Echipa ERP', 11, 1),
('Echipa Web', 12, 2),
('Echipa Mobile', 13, 3),
('Echipa HR', 14, 4),
('Echipa Suport', 15, 5);

-- Adăugăm sarcini (tasks)
INSERT INTO tasks (id, nume, supervizor, id_ang, start, end, status, id_prj) VALUES
(1, 'Analiza cerințelor ERP', 11, 1, '2023-01-10', '2023-02-28', 4, 1),
(2, 'Implementare modul financiar', 11, 6, '2023-03-01', '2023-05-31', 3, 1),
(3, 'Design interfață website', 12, 2, '2023-03-20', '2023-04-30', 4, 2),
(4, 'Dezvoltare frontend', 12, 7, '2023-05-01', '2023-06-30', 2, 2),
(5, 'Specificații aplicație mobilă', 13, 3, '2023-04-05', '2023-04-30', 4, 3),
(6, 'Dezvoltare aplicație iOS', 13, 8, '2023-05-01', '2023-08-31', 1, 3),
(7, 'Analiza proceselor HR', 14, 4, '2023-02-05', '2023-03-15', 4, 4),
(8, 'Dezvoltare sistem de evaluare', 14, 9, '2023-03-16', '2023-05-31', 3, 4),
(9, 'Design portal de suport', 15, 5, '2023-05-05', '2023-06-15', 4, 5),
(10, 'Implementare sistem de tichete', 15, 10, '2023-06-16', '2023-08-31', 2, 5);

-- Adăugăm locații pentru joburi
INSERT INTO locatii_joburi (id_locatie, id_job, strada, longitudine, latitudine, cod, oras, judet, tara) VALUES
(1, 1, 'Strada Principală nr. 1', 26.1025, 44.4268, '010101', 'București', 'București', 'România'),
(2, 2, 'Strada Secundară nr. 5', 23.6236, 46.7712, '400124', 'Cluj-Napoca', 'Cluj', 'România'),
(3, 3, 'Bulevardul Revoluției nr. 10', 21.2257, 45.7494, '300034', 'Timișoara', 'Timiș', 'România'),
(4, 4, 'Strada Alexandru Ioan Cuza nr. 8', 27.5730, 47.1733, '700052', 'Iași', 'Iași', 'România'),
(5, 5, 'Strada Decebal nr. 15', 23.5348, 46.0470, '510093', 'Alba Iulia', 'Alba', 'România');

-- Adăugăm joburi
INSERT INTO joburi (id, titlu, req, resp, dom, subdom, pozitie, departament, start, end, id_locatie, activ, keywords, id_team, id_prj, ore, tip) VALUES
(1, 'Specialist Recrutare', 'Experiență în recrutare minim 2 ani, cunoștințe HR', 'Recrutare personal, interviuri, onboarding', 'HR', 'Recrutare', 29, 1, '2023-05-01', '2023-06-30', 1, 1, 'HR, recrutare, interviuri', 4, 4, 40, 1),
(2, 'Dezvoltator Web', 'Cunoștințe HTML, CSS, JavaScript, React', 'Dezvoltarea și întreținerea aplicațiilor web', 'IT', 'Web Development', 36, 3, '2023-05-01', '2023-06-30', 2, 1, 'IT, web, React, frontend', 2, 2, 40, 1),
(3, 'Analist Financiar', 'Experiență în analiză financiară, Excel avansat', 'Analiză financiară, raportare, previziuni', 'Financiar', 'Analiză', 31, 2, '2023-05-01', '2023-06-30', 3, 1, 'financiar, analiză, raportare', 1, 1, 40, 1),
(4, 'Contabil Junior', 'Studii economice, cunoștințe contabilitate primară', 'Înregistrări contabile, raportări', 'Financiar', 'Contabilitate', 5, 2, '2023-05-01', '2023-06-30', 4, 1, 'contabilitate, financiar, junior', 1, 1, 40, 1),
(5, 'Tehnician IT', 'Cunoștințe hardware și software, troubleshooting', 'Suport tehnic, mentenanță echipamente', 'IT', 'Suport', 37, 3, '2023-05-01', '2023-06-30', 5, 1, 'IT, suport, hardware, software', 5, 5, 40, 1);

-- Adăugăm adeverințe
INSERT INTO adeverinte (id, tip, motiv, status, creare, modif, id_ang, pentru_servi) VALUES
(1, 1, 'Adeverință angajat pentru bancă', 2, '2023-04-01', '2023-04-02', 1, 'Banca Transilvania'),
(2, 2, 'Adeverință venit pentru credit', 1, '2023-04-05', '2023-04-06', 6, 'BRD'),
(3, 4, 'Adeverință concediu medical', 2, '2023-04-10', '2023-04-11', 3, 'Medic de familie'),
(4, 15, 'Adeverință venit pentru credit ipotecar', 0, '2023-04-15', NULL, 9, 'ING Bank'),
(5, 8, 'Adeverință vechime în muncă', 1, '2023-04-20', '2023-04-21', 7, 'Casa de Pensii');

-- Adăugăm concedii
INSERT INTO concedii (id_ang, start_c, end_c, motiv, locatie, status, tip, added, modified, acc_res, mentiuni) VALUES
(1, '2025-07-01', '2025-07-10', 'Concediu de odihnă', 'Grecia', 2, 1, '2025-04-01', '2025-04-05', '2025-04-05', NULL),
(2, '2025-07-15', '2025-07-25', 'Concediu de odihnă', 'Italia', 1, 1, '2025-04-05', '2025-04-08', '2025-04-08', NULL),
(3, '2025-06-01', '2025-06-05', 'Concediu medical', 'Acasă', 2, 3, '2025-05-30', '2025-05-31', '2025-05-31', 'Recomandare medicală'),
(6, '2025-08-01', '2025-08-15', 'Concediu de odihnă', 'Spania', 0, 1, '2025-05-01', NULL, NULL, NULL),
(9, '2025-09-01', '2025-09-07', 'Concediu de odihnă', 'Franța', 1, 1, '2025-05-15', '2025-05-20', '2025-05-20', NULL);

-- Adăugăm locații pentru concedii
INSERT INTO locatii_concedii (id_concediu, strada, longitudine, latitudine, cod, oras, judet, tara) VALUES
(1, 'Strada Plajei', 23.5, 39.5, '49100', 'Corfu', 'Corfu', 'Grecia'),
(2, 'Via Roma', 12.5, 41.9, '00100', 'Roma', 'Lazio', 'Italia'),
(3, 'Strada Principală', 26.1, 44.4, '010101', 'București', 'București', 'România'),
(4, 'Calle Mayor', -3.7, 40.4, '28013', 'Madrid', 'Madrid', 'Spania'),
(5, 'Rue de Rivoli', 2.3, 48.8, '75001', 'Paris', 'Île-de-France', 'Franța');

-- Adăugăm locații pentru departamente
INSERT INTO locatii_departamente (id_dep, strada, longitudine, latitudine, cod, oras, judet, tara) VALUES
(1, 'Strada Principală nr. 1, et. 2', 26.1025, 44.4268, '010101', 'București', 'București', 'România'),
(2, 'Strada Principală nr. 1, et. 3', 26.1025, 44.4268, '010101', 'București', 'București', 'România'),
(3, 'Strada Secundară nr. 5, et. 1', 23.6236, 46.7712, '400124', 'Cluj-Napoca', 'Cluj', 'România'),
(4, 'Strada Principală nr. 1, et. 1', 26.1025, 44.4268, '010101', 'București', 'București', 'România'),
(5, 'Strada Principală nr. 1, et. 4', 26.1025, 44.4268, '010101', 'București', 'București', 'România');

-- Adăugăm locații pentru useri
INSERT INTO locatii_useri (id_user, strada, longitudine, latitudine, cod, oras, judet, tara, id_sediu) VALUES
(1, 'Strada Unirii nr. 10', 26.1103, 44.4275, '030167', 'București', 'București', 'România', 1),
(2, 'Strada Libertății nr. 5', 26.0920, 44.4320, '050706', 'București', 'București', 'România', 1),
(3, 'Strada Unirii nr. 15', 26.1105, 44.4278, '030168', 'București', 'București', 'România', 1),
(4, 'Strada Basarab nr. 8', 26.0658, 44.4462, '010203', 'București', 'București', 'România', 1),
(5, 'Strada Libertății nr. 10', 26.0925, 44.4325, '050707', 'București', 'București', 'România', 1),
(6, 'Strada Doamnei nr. 3', 26.0978, 44.4338, '030016', 'București', 'București', 'România', 1),
(7, 'Strada Doamnei nr. 5', 26.0980, 44.4340, '030017', 'București', 'București', 'România', 1),
(8, 'Strada Frunzei nr. 12', 26.1220, 44.4390, '031478', 'București', 'București', 'România', 1),
(9, 'Strada Alunului nr. 7', 26.1150, 44.4350, '031256', 'București', 'București', 'România', 1),
(10, 'Strada Izvorului nr. 9', 26.0880, 44.4290, '050781', 'București', 'București', 'România', 1);

-- Adăugăm istorice de penalizări
INSERT INTO istoric_penalizari (id_ang, tip_penalizare, data_start, data_final, motiv) VALUES
(8, 1, '2025-03-01', '2025-05-31', 'Întârzieri repetate la program'),
(3, 3, '2025-04-01', '2025-06-30', 'Nerespectarea procedurilor interne'),
(10, 2, '2025-05-15', '2025-08-14', 'Absență nemotivată în data de 15.05.2023');

-- Adăugăm istorice de sporuri
INSERT INTO istoric_sporuri (id_ang, tip_spor, data_start, data_final, motiv) VALUES
(1, 3, '2025-01-01', '2025-12-31', 'Spor de vechime pentru peste 3 ani în companie'),
(6, 3, '2025-01-01', '2025-12-31', 'Spor de vechime pentru peste 3 ani în companie'),
(9, 3, '2025-01-01', '2025-12-31', 'Spor de vechime pentru peste 5 ani în companie'),
(4, 5, '2025-03-01', '2025-12-31', 'Spor de confidențialitate pentru acces la date sensibile'),
(6, 5, '2025-03-01', '2025-12-31', 'Spor de confidențialitate pentru acces la date sensibile'),
(7, 5, '2025-03-01', '2025-12-31', 'Spor de confidențialitate pentru acces la date financiare');

-- Adăugăm istoric de promovări
INSERT INTO istoric_promovari (id_ang, tip_vechi, tip_nou, tip_promovare, data_promovare) VALUES
(1, 3, 0, 'Promovare internă', '2024-06-01'),
(6, 10, 0, 'Promovare internă', '2025-04-01'),
(9, 8, 3, 'Promovare internă', '2025-01-15'),
(7, 5, 1, 'Promovare performanță', '2024-10-01');

-- Adăugăm istoric de concedii suplimentare
INSERT INTO istoric_concedii_suplimentare (id_ang, zile_acordate, motiv, data_acordare) VALUES
(1, 5, 'Performanță deosebită în Q1 2025', '2025-04-01'),
(6, 3, 'Finalizare proiect important', '2025-03-15'),
(9, 4, 'Vechime în companie peste 5 ani', '2025-01-01');

-- Adăugăm istoric fluture (salariu)
INSERT INTO istoric_fluture (id_ang, luna, an, salariu_brut, salariu_net, data_generare) VALUES
(1, 1, 2025, 13000.00, 7605.00, '2025-02-01'),
(1, 2, 2025, 13000.00, 7605.00, '2025-03-01'),
(1, 3, 2025, 13000.00, 7605.00, '2025-04-01'),
(1, 4, 2025, 13000.00, 7605.00, '2025-05-01'),
(6, 1, 2025, 13000.00, 7605.00, '2025-02-01'),
(6, 2, 2025, 13000.00, 7605.00, '2025-03-01'),
(6, 3, 2025, 13000.00, 7605.00, '2025-04-01'),
(6, 4, 2025, 13000.00, 7605.00, '2025-05-01'),
(9, 1, 2025, 11600.00, 6786.00, '2025-02-01'),
(9, 2, 2025, 11600.00, 6786.00, '2025-03-01'),
(9, 3, 2025, 11600.00, 6786.00, '2025-04-01'),
(9, 4, 2025, 11600.00, 6786.00, '2025-05-01');

-- Adăugăm cereri de demisie
INSERT INTO cereri_demisie (id_ang, motiv, data_cerere, data_ultima_zi, status) VALUES
(5, 'Ofertă mai bună de la altă companie', '2025-04-15', '2025-05-10', 'IN_ASTEPTARE'),
(8, 'Relocare în altă țară', '2025-05-01', '2025-04-30', 'APROBATA');

-- Șterge toate datele din denumiri_pozitii
TRUNCATE TABLE denumiri_pozitii;

-- Inserează datele pentru denumiri poziții verificând unicitatea
INSERT IGNORE INTO denumiri_pozitii (tip_pozitie, id_dep, denumire_completa) VALUES
-- Departamentul Financiar (id_dep = 2)
(23, 2, 'Director Financiar'),
(27, 2, 'Contabil Șef'),  -- Prima apariție pentru (27, 2)
(29, 2, 'Analist Financiar'),
(33, 2, 'Contabil'),
(31, 2, 'Specialist Control Intern'),
(30, 2, 'Specialist în Facturare și Colectare'),
-- A doua apariție pentru (27, 2) a fost eliminată pentru a evita duplicarea
-- (27, 2, 'Responsabil Bugete și Planificare Financiară'),

-- Resurse Umane (id_dep = 1)
(25, 1, 'Manager Resurse Umane'),
(29, 1, 'Specialist Recrutare și Selecție'),
(31, 1, 'Specialist Salarizare și Administrare Personal'),
(27, 1, 'Responsabil Formare și Dezvoltare'),
(28, 1, 'Responsabil Relații de Muncă'),
-- Am schimbat această înregistrare pentru a evita alt duplicat potențial
(26, 1, 'Specialist Compensații și Beneficii'),

-- Departamentul IT (id_dep = 3)
(23, 3, 'Director IT'),
(34, 3, 'Administrator de Rețea și Sisteme'),
(36, 3, 'Programator / Dezvoltator Software'),
(31, 3, 'Analist IT'),
(37, 3, 'Administrator de Bază de Date'),
-- Am schimbat această înregistrare pentru a evita alt duplicat potențial
(35, 3, 'Inginer de Securitate Cibernetică'),

-- Departamentul Comercial și Vânzări (id_dep = 6)
(23, 6, 'Director de Vânzări'),
(25, 6, 'Manager Regional de Vânzări'),
(33, 6, 'Consultant Vânzări'),
(31, 6, 'Analist de Piață'),
(26, 6, 'Coordonator E-commerce'),
(27, 6, 'Responsabil Relații Clienți');

-- Inserarea datelor inițiale despre atractii turistice
INSERT INTO locatii_atractii (nume, strada, longitudine, latitudine, cod, oras, judet, tara) VALUES 
('Castelul Bran', 'Strada General Traian Moșoiu', 25.3672, 45.5152, 507025, 'Bran', 'Brașov', 'România'),
('Castelul Peleș', 'Aleea Peleșului', 25.5764, 45.3595, 106100, 'Sinaia', 'Prahova', 'România'),
('Palatul Parlamentului', 'Strada Izvor', 26.0879, 44.4275, 050563, 'București', 'București', 'România'),
('Salina Turda', 'Aleea Durgăului', 23.7874, 46.5785, 401106, 'Turda', 'Cluj', 'România'),
('Cetatea Sighișoara', 'Strada Cetății', 24.7914, 46.2197, 545400, 'Sighișoara', 'Mureș', 'România'),
('Mănăstirea Voroneț', '-', 25.8606, 47.3976, 725301, 'Voroneț', 'Suceava', 'România'),
('Muzeul Astra', 'Strada Pădurea Dumbrava', 24.1256, 45.7879, 550399, 'Sibiu', 'Sibiu', 'România'),
('Castelul Corvinilor', 'Strada Castelului', 22.8892, 45.7499, 331141, 'Hunedoara', 'Hunedoara', 'România'),
('Biserica Neagră', 'Curtea Johannes Honterus', 25.5877, 45.6427, 500025, 'Brașov', 'Brașov', 'România'),
('Cetatea Râșnov', 'Strada Cetății', 25.4606, 45.5909, 505400, 'Râșnov', 'Brașov', 'România');

-- Inserarea datelor pentru sărbători
INSERT INTO sarbatori (zi, nume) VALUES
('2023-01-01', 'Anul Nou'),
('2023-01-02', 'A doua zi de Anul Nou'),
('2023-01-24', 'Ziua Unirii Principatelor Române'),
('2023-04-14', 'Vinerea Mare'),
('2023-04-16', 'Paștele Ortodox'),
('2023-04-17', 'A doua zi de Paște Ortodox'),
('2023-05-01', 'Ziua Muncii'),
('2023-06-04', 'Rusaliile'),
('2023-06-05', 'A doua zi de Rusalii'),
('2023-08-15', 'Adormirea Maicii Domnului'),
('2023-11-30', 'Sfântul Andrei'),
('2023-12-01', 'Ziua Națională a României'),
('2023-12-25', 'Crăciunul'),
('2023-12-26', 'A doua zi de Crăciun');

-- Inserarea datelor pentru zile libere suplimentare
INSERT INTO libere (zi, nume) VALUES
('2023-01-23', 'Punte Ziua Unirii'),
('2023-04-18', 'Punte Paște'),
('2023-06-01', 'Ziua Copilului'),
('2023-06-02', 'Punte Weekend'),
('2023-12-27', 'Punte Crăciun');

-- Inserarea datelor pentru culori
INSERT INTO colors (culoare, cod) VALUES
('Albastru', '#3A8DFF'),
('Roșu', '#FF5733'),
('Verde', '#42E695'),
('Mov', '#9B59B6'),
('Galben', '#FFD700'),
('Portocaliu', '#E74C3C'),
('Turcoaz', '#1ABC9C'),
('Auriu', '#F39C12'),
('Indigo', '#8E44AD'),
('Verde Smarald', '#2ECC71');

-- Actualizare culoare pentru utilizatori
UPDATE useri SET culoare = (SELECT cod FROM colors WHERE culoare = 'Albastru') WHERE id = 1;
UPDATE useri SET culoare = (SELECT cod FROM colors WHERE culoare = 'Roșu') WHERE id = 2;
UPDATE useri SET culoare = (SELECT cod FROM colors WHERE culoare = 'Verde') WHERE id = 3;
UPDATE useri SET culoare = (SELECT cod FROM colors WHERE culoare = 'Mov') WHERE id = 4;
UPDATE useri SET culoare = (SELECT cod FROM colors WHERE culoare = 'Galben') WHERE id = 5;
UPDATE useri SET culoare = (SELECT cod FROM colors WHERE culoare = 'Portocaliu') WHERE id = 6;
UPDATE useri SET culoare = (SELECT cod FROM colors WHERE culoare = 'Turcoaz') WHERE id = 7;
UPDATE useri SET culoare = (SELECT cod FROM colors WHERE culoare = 'Auriu') WHERE id = 8;
UPDATE useri SET culoare = (SELECT cod FROM colors WHERE culoare = 'Indigo') WHERE id = 9;
UPDATE useri SET culoare = (SELECT cod FROM colors WHERE culoare = 'Verde Smarald') WHERE id = 10;

INSERT INTO tipuri_evenimente (id, denumire) VALUES
(1, 'Workshop'),
(2, 'Training'),
(3, 'Conferință');

-- Reactivează constrângerile FOREIGN KEY
SET FOREIGN_KEY_CHECKS = 1;

-- 6. Ready to use =) Enjoy
-- -----------------------------------------------------
-- QUERY-URI
-- -----------------------------------------------------
SELECT c.acc_res, 
	c.added, 
	c.modified, 
	c.id AS nr_crt, 
	d.nume_dep AS departament, 
	u.nume, 
	u.prenume, 
	t.denumire AS functie, 
	c.start_c, 
	c.end_c, 
	c.motiv, 
	c.locatie, 
	s.nume_status AS status, 
	ct.motiv as tipcon 
FROM useri u 
JOIN tipuri t ON u.tip = t.tip
JOIN departament d ON u.id_dep = d.id_dep
JOIN concedii c ON c.id_ang = u.id
JOIN statusuri s ON c.status = s.status
JOIN tipcon ct ON c.tip = ct.tip
where c.id_ang = 14
and u.username <> "test"
and YEAR(c.start_c) = YEAR(CURDATE()); 

SELECT c.id AS nr_crt,
		c.id_ang, 
		u.nume,
		u.prenume, 
		d.nume_dep AS departament, 
		t.denumire AS functie, 
       c.start_c, 
       c.end_c, 
       c.motiv, 
       CONCAT('Str.', l.strada, ', loc. ', l.oras, ', jud. ', l.judet, ', ', l.tara) as adresa, 
       ct.motiv as tipcon, 
       s.nume_status AS status, 
       c.added, 
       c.modified, 
       c.acc_res
FROM concedii c 
JOIN useri u ON u.id = c.id_ang 
JOIN tipuri t ON u.tip = t.tip 
JOIN departament d ON u.id_dep = d.id_dep 
JOIN statusuri s ON c.status = s.status 
JOIN tipcon ct ON c.tip = ct.tip 
LEFT JOIN locatii_concedii l ON c.id = l.id_concediu;

SELECT
	c.id_ang,
    u.id, 
	c.acc_res, 
    c.added, 
    c.modified, 
    c.id AS nr_crt, 
    d.nume_dep AS departament, 
    u.nume, 
    u.prenume, 
    t.denumire AS functie, 
    c.start_c, 
    c.end_c, 
    c.motiv, 
    c.locatie, 
    s.nume_status AS status, 
    ct.motiv as tipcon, 
    CONCAT('Str.', l.strada, ', loc. ', l.oras, ', jud. ', l.judet, ', ', l.tara) as adresa
FROM concedii c 
JOIN useri u ON u.id = c.id_ang 
JOIN tipuri t ON u.tip = t.tip 
JOIN departament d ON u.id_dep = d.id_dep 
JOIN statusuri s ON c.status = s.status 
JOIN tipcon ct ON c.tip = ct.tip 
LEFT JOIN locatii_concedii l ON c.id = l.id_concediu 
WHERE YEAR(c.start_c) = YEAR(CURDATE()) and u.id_dep = 1 and c.status = 1;

SELECT nume, prenume, username, denumire, nume_dep 
FROM useri 
left JOIN tipuri on tipuri.tip = useri.tip 
left JOIN departament on departament.id_dep = useri.id_dep 
WHERE username <> "test";

SELECT
	c.id_ang, 
    u.id, 
    c.acc_res, 
    c.added, 
    c.modified, 
    c.id AS nr_crt, 
    d.nume_dep AS departament, 
    u.nume, 
    u.prenume, 
    t.denumire AS functie, 
    c.start_c, 
    c.end_c, 
    c.motiv, 
    c.locatie, 
    s.nume_status AS status, 
    ct.motiv as tipcon, 
    CONCAT('Str.', l.strada, ', loc. ', l.oras, ', jud. ', l.judet, ', ', l.tara) as adresa
FROM concedii c
JOIN useri u ON u.id = c.id_ang 
JOIN tipuri t ON u.tip = t.tip 
JOIN departament d ON u.id_dep = d.id_dep 
JOIN statusuri s ON c.status = s.status 
JOIN tipcon ct ON c.tip = ct.tip 
LEFT JOIN locatii_concedii l ON c.id = l.id_concediu 
WHERE YEAR(c.start_c) = YEAR(CURDATE()) and u.id_dep = 1 and c.status = 1;

SELECT
	c.acc_res, 
    c.added, 
    c.modified, 
    c.id AS nr_crt, 
    d.nume_dep AS departament, 
    u.nume, u.prenume, 
    t.denumire AS functie, 
    c.start_c, 
    c.end_c, 
    c.motiv, 
    c.locatie, 
    s.nume_status AS status, 
    ct.motiv as tipcon
FROM useri u 
JOIN tipuri t ON u.tip = t.tip 
JOIN departament d ON u.id_dep = d.id_dep 
JOIN concedii c ON c.id_ang = u.id 
JOIN statusuri s ON c.status = s.status 
JOIN tipcon ct ON c.tip = ct.tip 
where c.id_ang = 11 
and u.username <> "test" 
and YEAR(c.start_c) = YEAR(CURDATE()); 

SELECT DISTINCT l.strada, l.oras, l.judet FROM locatii_useri l
join useri u on u.id=l.id_user
where u.id_dep = (select u1.id_dep from useri u1 where u1.id = 14) 
ORDER BY l.oras;

SELECT DISTINCT u.*,  
                t.denumire AS functie, 
                t.ierarhie as ierarhie,
                d.nume_dep,
                dp.denumire_completa AS denumire_specifică
FROM useri u 
JOIN tipuri t ON u.tip = t.tip 
JOIN departament d ON u.id_dep = d.id_dep 
LEFT JOIN denumiri_pozitii dp ON t.tip = dp.tip_pozitie AND d.id_dep = dp.id_dep;

SELECT c.acc_res, c.added, c.modified, c.id AS nr_crt, d.nume_dep AS departament, u.nume, u.prenume, t.denumire AS functie, c.start_c, c.end_c, c.motiv, c.locatie, s.nume_status AS status, ct.motiv as tipcon FROM useri u JOIN tipuri t ON u.tip = t.tip JOIN departament d ON u.id_dep = d.id_dep JOIN concedii c ON c.id_ang = u.id JOIN statusuri s ON c.status = s.status JOIN tipcon ct ON c.tip = ct.tip  WHERE u.username <> 'test' AND YEAR(c.start_c) = YEAR(CURDATE());

SELECT strada, oras, judet, nume, prenume, nume_dep FROM locatii_concedii join concedii on locatii_concedii.id_concediu = concedii.id join useri on useri.id = concedii.id_ang join departament on useri.id_dep = departament.id_dep ORDER BY oras;
-- ce tipuri de angajati exista in departamentul IT?
select distinct tipuri.denumire from useri join departament on useri.id_dep = departament.id_dep join tipuri on tipuri.tip = useri.tip where upper(departament.nume_dep) like "%IT%";

-- select group_concat(denumire separator ', ') as penalizari from istoric_penalizari join tipuri_penalizari on istoric_penalizari.tip_penalizare = tipuri_penalizari.id where id_ang = ? and istoric_penalizari.data_start < current_date() and istoric_penalizari.data_final > current_date();
-- select group_concat(denumire separator ', ') as sporuri from istoric_sporuri join tipuri_sporuri on istoric_sporuri.tip_spor = tipuri_sporuri.id where id_ang = ? and istoric_sporuri.data_start < current_date() and istoric_sporuri.data_final > current_date();
-- select group_concat(nume separator ', ') as echipe from membrii_echipe join echipe on echipe.id = membrii_echipe.id_echipa join proiecte on echipe.id_prj = proiecte.id where membrii_echipe.id_ang = ?;
-- select group_concat(echipe.nume separator ', ') as echipe from membrii_echipe join echipe on echipe.id = membrii_echipe.id_echipa join proiecte on echipe.id_prj = proiecte.id;

select group_concat(echipe.nume separator ', ') as nume_echipe from membrii_echipe join echipe on echipe.id = membrii_echipe.id_echipa join proiecte on echipe.id_prj = proiecte.id join useri u on u.id = membrii_echipe.id_ang where proiecte.start < current_date() and proiecte.end > current_date();

select group_concat(nume separator ', ') as proiecte from proiecte where proiecte.start < current_date() and proiecte.end > current_date();

SELECT 
    u.id, 
    u.nume, 
    u.prenume, 
    u.data_nasterii, 
    u.email, 
    u.telefon, 
    u.conluate, 
    u.zilecons, 
    u.data_ang, 
    u.data_modif, 
    d.nume_dep,
    t.salariu, 
    (select group_concat(denumire separator ', ') as sporuri from istoric_sporuri join tipuri_sporuri on istoric_sporuri.tip_spor = tipuri_sporuri.id where id_ang = u.id and istoric_sporuri.data_start < current_date() and istoric_sporuri.data_final > current_date()) as sporuri,
    (select group_concat(denumire separator ', ') as penalizari from istoric_penalizari join tipuri_penalizari on istoric_penalizari.tip_penalizare = tipuri_penalizari.id where id_ang = u.id and istoric_penalizari.data_start < current_date() and istoric_penalizari.data_final > current_date()) as penalizari,
    t.denumire AS denumire_pozitie, -- Using existing column instead of denumiri_pozitii.denumire_completa
    l.strada, 
    l.oras, 
    l.judet, 
    l.tara,
	sd.nume_sediu AS nume_sediu,
    (select group_concat(echipe.nume separator ', ') as nume_echipe from membrii_echipe join echipe on echipe.id = membrii_echipe.id_echipa join proiecte on echipe.id_prj = proiecte.id join useri u on u.id = membrii_echipe.id_ang where proiecte.start < current_date() and proiecte.end > current_date() and membrii_echipe.id_ang = u.id) as nume_echipe
FROM 
    useri u
LEFT JOIN
	sedii sd ON sd.id_sediu = u.id_sediu
LEFT JOIN 
    departament d ON u.id_dep = d.id_dep
LEFT JOIN 
    tipuri t ON u.tip = t.tip
LEFT JOIN 
    locatii_useri l ON u.id = l.id_user; 

SELECT 
    c.id AS id_concediu,
    u.nume, 
    u.prenume, 
    d.nume_dep AS departament,
    t.denumire AS pozitie,
    u.email, 
    u.telefon, 
    u.data_nasterii, 
    l.strada, 
    l.oras, 
    l.judet, 
    l.tara,
    tc.motiv as tip_concediu, 
    s.nume_status AS status_concediu,
    c.durata, 
    c.added AS data_adaugare, 
    c.modified AS data_modificare, 
    c.acc_res AS data_aprobare_respingere, 
    c.mentiuni,
    u.conluate, 
    u.zilecons,
    (select group_concat(echipe.nume separator ', ') as nume_echipe from membrii_echipe join echipe on echipe.id = membrii_echipe.id_echipa join proiecte on echipe.id_prj = proiecte.id join useri u on u.id = membrii_echipe.id_ang where proiecte.start < current_date() and proiecte.end > current_date() and membrii_echipe.id_ang = u.id) as nume_echipe,
    sd.nume_sediu AS nume_sediu,
    lc.oras, 
    lc.judet, 
    lc.tara
FROM 
    concedii c
LEFT JOIN useri u ON u.id = c.id_ang
LEFT JOIN locatii_useri l ON u.id = l.id_user
LEFT JOIN sedii sd ON sd.id_sediu = u.id_sediu
LEFT JOIN departament d ON u.id_dep = d.id_dep
LEFT JOIN tipuri t ON u.tip = t.tip
LEFT JOIN statusuri s ON c.status = s.status
LEFT JOIN tipcon tc ON c.tip = tc.tip
LEFT JOIN locatii_concedii lc ON c.id = lc.id_concediu
WHERE c.id IS NOT NULL;

SELECT 
    a.id AS id_adeverinta,
    a.motiv,
    ta.denumire AS tip_adeverinta,
    s.nume_status AS status_adeverinta,
    a.creare AS data_creare,
    a.modif AS data_modificare,
    u.nume,
    u.prenume,
    u.email,
    u.telefon,
    u.data_nasterii,
    u.cnp,
    d.nume_dep AS departament,
    t.denumire AS pozitie,
    u.data_ang AS data_angajare,
    u.data_modif AS data_modificare_angajat,
    lu.oras AS oras_angajat,
    lu.judet AS judet_angajat,
    lu.tara AS tara_angajat,
    (select group_concat(echipe.nume separator ', ') as nume_echipe from membrii_echipe join echipe on echipe.id = membrii_echipe.id_echipa join proiecte on echipe.id_prj = proiecte.id join useri u on u.id = membrii_echipe.id_ang where proiecte.start < current_date() and proiecte.end > current_date() and membrii_echipe.id_ang = u.id) as nume_echipe,
    sd.nume_sediu AS nume_sediu
FROM 
    adeverinte a
LEFT JOIN 
    useri u ON u.id = a.id_ang
LEFT JOIN
	sedii sd ON sd.id_sediu = u.id_sediu
LEFT JOIN 
    tip_adev ta ON a.tip = ta.id
LEFT JOIN 
    statusuri s ON a.status = s.status
LEFT JOIN 
    departament d ON u.id_dep = d.id_dep
LEFT JOIN 
    tipuri t ON u.tip = t.tip
LEFT JOIN 
    locatii_useri lu ON u.id = lu.id_user
WHERE 
    a.id IS NOT NULL;

select u.nume, u.prenume, u.data_nasterii, u.email, u.telefon from useri u join departament d on u.id_dep = d.id_dep where upper(d.nume_dep) like "%HR%";

SELECT c.id, u.nume, u.prenume, d.nume_dep AS departament, t.denumire AS functie, c.start_c, c.end_c, c.motiv, c.locatie, s.nume_status AS status, c.durata, tc.motiv AS tip_concediu FROM concedii c JOIN useri u ON c.id_ang = u.id JOIN departament d ON u.id_dep = d.id_dep JOIN tipuri t ON u.tip = t.tip JOIN statusuri s ON c.status = s.status JOIN tipcon tc ON c.tip = tc.tip  ORDER BY c.start_c DESC;

-- -----------------------------------------------------
-- test
-- -----------------------------------------------------
select * from useri;
SELECT id, nume FROM echipe WHERE id_prj = 1;
SELECT status, COUNT(*) as count FROM concedii join useri on concedii.id_ang = useri.id GROUP by status;
SELECT SUM(CASE WHEN MONTH(start_c) = 1 THEN durata ELSE 0 END) as ian, SUM(CASE WHEN MONTH(start_c) = 2 THEN durata ELSE 0 END) as feb, SUM(CASE WHEN MONTH(start_c) = 3 THEN durata ELSE 0 END) as mar, SUM(CASE WHEN MONTH(start_c) = 4 THEN durata ELSE 0 END) as apr, SUM(CASE WHEN MONTH(start_c) = 5 THEN durata ELSE 0 END) as mai, SUM(CASE WHEN MONTH(start_c) = 6 THEN durata ELSE 0 END) as iun, SUM(CASE WHEN MONTH(start_c) = 7 THEN durata ELSE 0 END) as iul, SUM(CASE WHEN MONTH(start_c) = 8 THEN durata ELSE 0 END) as aug, SUM(CASE WHEN MONTH(start_c) = 9 THEN durata ELSE 0 END) as sept, SUM(CASE WHEN MONTH(start_c) = 10 THEN durata ELSE 0 END) as oct, SUM(CASE WHEN MONTH(start_c) = 11 THEN durata ELSE 0 END) as nov, SUM(CASE WHEN MONTH(start_c) = 12 THEN durata ELSE 0 END) as decm FROM concedii join useri on concedii.id_ang = useri.id WHERE YEAR(start_c) = YEAR(CURDATE()) AND status >= 0 GROUP BY status;
SELECT status, COUNT(*) as count FROM concedii join useri on concedii.id_ang = useri.id GROUP BY status;
SELECT SUM(CASE WHEN MONTH(start_c) = 1 THEN durata ELSE 0 END) as ian, SUM(CASE WHEN MONTH(start_c) = 2 THEN durata ELSE 0 END) as feb, SUM(CASE WHEN MONTH(start_c) = 3 THEN durata ELSE 0 END) as mar, SUM(CASE WHEN MONTH(start_c) = 4 THEN durata ELSE 0 END) as apr, SUM(CASE WHEN MONTH(start_c) = 5 THEN durata ELSE 0 END) as mai, SUM(CASE WHEN MONTH(start_c) = 6 THEN durata ELSE 0 END) as iun FROM concedii JOIN useri ON concedii.id_ang = useri.id WHERE YEAR(start_c) = YEAR(CURDATE()) AND status >= 0 AND useri.id_dep = 1
;
select count(*) from concedii c join useri u on u.id = c.id_ang join departament d on d.id_dep = u.id_dep where upper(d.nume_dep) like "%IT%" and (month(c.start_c) = 7 or month(c.end_c) = 7); 

SELECT DISTINCT u.id, u.nume, u.prenume FROM useri u JOIN membrii_echipe me ON u.id = me.id_ang WHERE me.id_echipa IN (" 1 ") ORDER BY u.nume, u.prenume;
update useri set id_sediu = 1 where id = 1;
select * from penalizari;
select * from tipcon;
SELECT c.acc_res, c.added, c.modified, c.id AS nr_crt, d.nume_dep AS departament, u.nume, u.prenume, t.denumire AS functie, c.start_c, c.end_c, c.motiv, CASE WHEN lc.strada IS NOT NULL THEN CONCAT('Str.', lc.strada, ', loc. ', lc.oras, ', jud. ', lc.judet, ', ', lc.tara) ELSE 'Locație nespecificată' END AS locatie, s.nume_status AS status, ct.motiv AS tipcon FROM useri u JOIN tipuri t ON u.tip = t.tip JOIN departament d ON u.id_dep = d.id_dep JOIN concedii c ON c.id_ang = u.id JOIN statusuri s ON c.status = s.status JOIN tipcon ct ON c.tip = ct.tip LEFT JOIN locatii_concedii lc ON c.id = lc.id_concediu  WHERE u.id <> 1 AND YEAR(c.start_c) = YEAR(CURDATE())